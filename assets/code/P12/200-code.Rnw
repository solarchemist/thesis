<<'0512P-lightsource-and-cuvette-data'>>=
# absorption of PMMA cuvette itself with different contents: air, water, ethanol
# baseline files (light source, cuvettes with and without contents)
baseline.files <-
   list.files(
      path = here::here("assets/data/P12/uvvis"),
      pattern = "\\.txt$",
      full.names = TRUE)
lightsource <-
   OO2df(
      datafile = baseline.files[grep(pattern = "reference\\.txt$", x = baseline.files)],
      version = "1")
# cuvettes with and without contents (from baseline.files)
cuvette.files <- baseline.files[grep(pattern = "cuvette.*\\.txt$", x = baseline.files)]
cuvettes <-
   OO2df(datafile = cuvette.files[1], version = "1")
for (i in 2:length(cuvette.files)) {
   cuvettes <-
      rbind(
         cuvettes,
         OO2df(datafile = cuvette.files[i], version = "1"))
}
cuvettes$energy <- wavelength2energy(cuvettes$wavelength)
cuvettes$sampleid[which(cuvettes$sampleid == "cuvette")] <- "Air"
cuvettes$sampleid[which(cuvettes$sampleid == "cuvette+water")] <- "\\ch{H2O}"
cuvettes$sampleid[which(cuvettes$sampleid == "cuvette+EtOH")] <- "EtOH"
@


<<'0512P-MB-abs-band'>>=
MB.band      <- 665 # nm
MB2.band     <- 629 # nm
MB3.band     <- 612 # nm
MB.bandwidth <-  10 # nm
@


<<'0512P-MB-abs-coeff'>>=
if (file.exists(here::here("assets/data/P12/uvvis/abscoeff.rda"))) {
   abs.coeff <- common::LoadRData2Variable(here::here("assets/data/P12/uvvis/abscoeff.rda"))
}
# abs coeff at MB max peak
# calculated based on approx 20 values, and here we use the standard deviation as the error
abs.coeff.MB.max <-
   set_errors(
      abs.coeff %>%
         filter(dye == "MB") %>%
         filter(solution == "H2O+EtOH") %>%
         filter(wavelength > MB.band - 0.5 * MB.bandwidth & wavelength < MB.band + 0.5 * MB.bandwidth) %>%
         select(k) %>%
         unlist(use.names = F) %>%
         mean(),
      abs.coeff %>%
         filter(dye == "MB") %>%
         filter(solution == "H2O+EtOH") %>%
         filter(wavelength > MB.band - 0.5 * MB.bandwidth & wavelength < MB.band + 0.5 * MB.bandwidth) %>%
         select(k) %>%
         unlist(use.names = F) %>%
         sd())
@


<<'0512P-figref-MB-abs-coefficient', eval=FALSE, echo=FALSE>>=
this.coeff <-
   abs.coeff %>%
   filter(dye == "MB") %>%
   mutate(solution =
      # https://dplyr.tidyverse.org/reference/case_match.html
      case_match(
         solution,
         "H2O" ~ "\\water",
         "H2O+EtOH" ~ "\\water{} + \\EtOH{} (90:10)"))
slice <-
   this.coeff %>%
   filter(wavelength > 600) %>%
   filter(wavelength == min(wavelength))
p.mb.abs.coeff <- ggplot(
   data = this.coeff %>%
      filter(wavelength < 900)) +
   # add MB structure as tikz annotation
   annotate("text",
      x = 405, y = 4.9e4,
      label =
         "\\footnotesize\\scalebox{0.75}{\\chemfig{[7]H_3C-N(-[6]CH_3)-[:30]*6(=-(*6(=\\chembelow{S}{\\scriptscriptstyle\\oplus}(!\\nobond\\chemabove{Cl}{\\scriptscriptstyle\\ominus})-(*6(-=(-N(-[1]CH_3)-[6]CH_3)-=-=))--N=-))--=-)}}") +
   geom_label_repel(
      data = slice,
      aes(
         x = wavelength, y = k,
         label = solution, colour = solution),
         size = 2.5, nudge_x = -120, direction = "x") +
   geom_path(aes(x = wavelength, y = k, colour = solution)) +
   scale_color_brewer(type = "qual", palette = 2) +
   scale_x_continuous(breaks = seq(200, 900, 100)) +
   scale_y_continuous(breaks = c(0, 2e4, 4e4), labels = c(0, 2, 4)) +
   labs(
      x = "$\\lambda/\\unit{\\nm}$",
      y = "$\\alpha/\\num[retain-unity-mantissa = false]{1e4}\\unit{\\litre\\per\\mole\\per\\cm}$") +
   theme(legend.position = "none")
@


<<'0512P-mb-fityk'>>=
# @0 < here::here('assets/data/P12/abscoeff-H2O+EtOH.csv')
# adjusted the baseline (mainly for the UV segment)
# locked the position of the 500 nm peak
# @0 < here::here('assets/data/P12/abscoeff-H2O.csv')
mb.bands.fitted <-
   rbind(
      cbind(
         solvent = "H2O",
         read.table(
            here::here("assets/data/P12/uvvis/abscoeff-H2O.peaks"),
            skip = 1,
            # skip the last three columns (fityk's output is verbose)
            colClasses = c(rep(NA, 6), rep("NULL", 3)),
            col.names = c("peak", "type", "center", "height", "area", "fwhm", "", "", ""))),
      cbind(
         solvent = "H2O+EtOH",
         read.table(
            here::here("assets/data/P12/uvvis/abscoeff-H2O+EtOH.peaks"),
            skip = 1,
            # skip the last three columns (fityk's output is verbose)
            colClasses = c(rep(NA, 6), rep("NULL", 3)),
            col.names = c("peak", "type", "center", "height", "area", "fwhm", "", "", ""))))
# clean up the peak column
mb.bands.fitted$peak <- sub("%_", "", mb.bands.fitted$peak)
@


<<'0512P-figref-MB-water-fitted', eval=FALSE, echo=FALSE>>=
df <-
   read.table(file = here::here("assets/data/P12/uvvis/abscoeff-H2O.dat"))
names(df) <-
   c("wl", "abs",
     "F1", "F2", "F3", "F4", "F5", "F6", "F7",
     "model", "residuals")
p.mb.abs.water <- ggplot(data = df) +
   geom_point(
      aes(x = wl, y = abs),
      size = 0.2, colour = "#1A9E77") +
   geom_line(
      aes(x = wl, y = model),
      colour = "black") +
   # residuals
   geom_line(
      aes(x = wl, y = residuals),
      colour = alpha("blue", 0.3)) +
   geom_line(
      aes(x = wl, y = F1),
      colour = "red") +
   geom_line(
      aes(x = wl, y = F2),
      colour = "red") +
   geom_line(
      aes(x = wl, y = F3),
      colour = "red") +
   geom_line(
      aes(x = wl, y = F4),
      colour = "red") +
   geom_line(
      aes(x = wl, y = F5),
      colour = "red") +
   geom_line(
      aes(x = wl, y = F6),
      colour = "red") +
   geom_line(
      aes(x = wl, y = F7),
      colour = "red") +
   # numeric labels
   geom_text(
      data = mb.bands.fitted %>% filter(solvent == "H2O") %>% filter(peak %in% c(1, 3)),
      aes(x = center, y = height + 4E3, label = paste0("\\textsf{", peak, "}")),
      colour = "red", fontface = "bold", size = 2.0) +
   geom_text(
      data = mb.bands.fitted %>% filter(solvent == "H2O") %>% filter(peak == 2),
      aes(x = center, y = height - 5E3, label = paste0("\\textsf{", peak, "}")),
      colour = "red", fontface = "bold", size = 2.0) +
   # solvent label
   annotate("text",
      x = -Inf, y = Inf, hjust = -0.15, vjust = 1.75, size = 2.5,
      label = "\\textit{(a)} \\water") +
   coord_cartesian(xlim = c(500, 750),
                   ylim = c(0, 54E3)) +
   scale_y_continuous(breaks = c(0, 20E3, 40E3),
                      labels = c("0", "2", "4")) +
   scale_x_continuous(breaks = seq(200, 1000, 100)) +
   labs(y = "$\\alpha/\\num[retain-unity-mantissa = false]{1e4}\\unit{\\litre\\per\\mole\\per\\cm}$",
        x = "$\\lambda/\\unit{\\nm}$") +
   theme(axis.text = element_text(size = rel(0.8)),
         axis.title = element_text(size = rel(0.85)))
@


<<'0512P-figref-MB-ethanol-fitted', eval=FALSE, echo=FALSE>>=
df <-
   read.table(file = here::here("assets/data/P12/uvvis/abscoeff-H2O+EtOH.dat"))
names(df) <-
   c("wl", "abs",
     "F1", "F2", "F3", "F4", "F5", "F6",
     "model", "residuals")
p.mb.abs.etoh <- ggplot(data = df) +
   geom_point(
      aes(x = wl, y = abs),
      size = 0.2, colour = "#D85F01") +
   geom_line(
      aes(x = wl, y = model),
      colour = "black") +
   # residuals
   geom_line(
      aes(x = wl, y = residuals),
      colour = alpha("blue", 0.3)) +
   geom_line(
      aes(x = wl, y = F1),
      colour = "red") +
   geom_line(
      aes(x = wl, y = F2),
      colour = "red") +
   geom_line(
      aes(x = wl, y = F3),
      colour = "red") +
   geom_line(
      aes(x = wl, y = F4),
      colour = "red") +
   geom_line(
      aes(x = wl, y = F5),
      colour = "red") +
   geom_line(
      aes(x = wl, y = F6),
      colour = "red") +
   # numeric labels
   geom_text(
      data = mb.bands.fitted %>% filter(solvent == "H2O+EtOH") %>% filter(peak %in% c(1, 2)),
      aes(x = center, y = height - 5E3, label = paste0("\\textsf{", peak, "}")),
      colour = "red", fontface = "bold", size = 2.0) +
   # solvent label
   annotate("text",
      # for some reason same hjust as for panel b does not produce the same result... had to tweak
      x = -Inf, y = Inf, hjust = -0.05, vjust = 1.75, size = 2.5,
      label = "\\textit{(b)} \\water:\\EtOH") +
   coord_cartesian(xlim = c(500, 750), ylim = c(0, 54E3)) +
   scale_y_continuous(breaks = c(0, 20E3, 40E3),
                      labels = c("0", "2", "4")) +
   scale_x_continuous(breaks = seq(200, 1000, 100)) +
   labs(y = "$\\alpha/\\num[retain-unity-mantissa = false]{1e4}\\unit{\\litre\\per\\mole\\per\\cm}$",
        x = "$\\lambda/\\unit{\\nm}$") +
   theme(axis.text = element_text(size = rel(0.8)),
         axis.title = element_text(size = rel(0.85)))
@




<<'0512P-abs-coeff-MB-peak-absorbance'>>=
abs.coeff.df <-
   data.frame(
      structure(dimnames =
                   list(
                      # rownames
                      c("H2O", "H2O:EtOH"),
                      # colnames
                      # c("wl293", "wl610", "wl665")),
                      c("wl612", "wl629", "wl665")),
                matrix(c("", "", "",
                         "", "", ""),
                       ncol = 3, byrow = T)))
abs.coeff.df$wl665 <-
   c(paste(abs.coeff %>% filter(dye == "MB") %>% filter(solution == "H2O") %>%
              filter(wavelength > MB.band - 0.5 * MB.bandwidth & wavelength < MB.band + 0.5 * MB.bandwidth) %>%
              select(k) %>% unlist(use.names=F) %>% mean() %>% signif(3), "+-",
           abs.coeff %>% filter(dye == "MB") %>% filter(solution == "H2O") %>%
              filter(wavelength > MB.band - 0.5 * MB.bandwidth & wavelength < MB.band + 0.5 * MB.bandwidth) %>%
              select(k) %>% unlist(use.names=F) %>% sd() %>% signif(3)),
     paste(abs.coeff %>% filter(dye == "MB") %>% filter(solution == "H2O+EtOH") %>%
              filter(wavelength > MB.band - 0.5 * MB.bandwidth & wavelength < MB.band + 0.5 * MB.bandwidth) %>%
              select(k) %>% unlist(use.names=F) %>% mean() %>% signif(3), "+-",
           abs.coeff %>% filter(dye == "MB") %>% filter(solution == "H2O+EtOH") %>%
              filter(wavelength > MB.band - 0.5 * MB.bandwidth & wavelength < MB.band + 0.5 * MB.bandwidth) %>%
              select(k) %>% unlist(use.names=F) %>% sd() %>% signif(3)))
abs.coeff.df$wl629 <-
   c(paste(abs.coeff %>% filter(dye == "MB") %>% filter(solution == "H2O") %>%
              filter(wavelength > MB2.band - 0.5 * MB.bandwidth & wavelength < MB2.band + 0.5 * MB.bandwidth) %>%
              select(k) %>% unlist(use.names=F) %>% mean() %>% signif(4), "+-",
           abs.coeff %>% filter(dye == "MB") %>% filter(solution == "H2O") %>%
              filter(wavelength > MB2.band - 0.5 * MB.bandwidth & wavelength < MB2.band + 0.5 * MB.bandwidth) %>%
              select(k) %>% unlist(use.names=F) %>% sd() %>% signif(2)),
     paste(abs.coeff %>% filter(dye == "MB") %>% filter(solution == "H2O+EtOH") %>%
              filter(wavelength > MB2.band - 0.5 * MB.bandwidth & wavelength < MB2.band + 0.5 * MB.bandwidth) %>%
              select(k) %>% unlist(use.names=F) %>% mean() %>% signif(4), "+-",
           abs.coeff %>% filter(dye == "MB") %>% filter(solution == "H2O+EtOH") %>%
              filter(wavelength > MB2.band - 0.5 * MB.bandwidth & wavelength < MB2.band + 0.5 * MB.bandwidth) %>%
              select(k) %>% unlist(use.names=F) %>% sd() %>% signif(2)))
abs.coeff.df$wl612 <-
   c(paste(abs.coeff %>% filter(dye == "MB") %>% filter(solution == "H2O") %>%
              filter(wavelength > MB3.band - 0.5 * MB.bandwidth & wavelength < MB3.band + 0.5 * MB.bandwidth) %>%
              select(k) %>% unlist(use.names=F) %>% mean() %>% signif(3), "+-",
           abs.coeff %>% filter(dye == "MB") %>% filter(solution == "H2O") %>%
              filter(wavelength > MB3.band - 0.5 * MB.bandwidth & wavelength < MB3.band + 0.5 * MB.bandwidth) %>%
              select(k) %>% unlist(use.names=F) %>% sd() %>% signif(3)),
     paste(abs.coeff %>% filter(dye == "MB") %>% filter(solution == "H2O+EtOH") %>%
              filter(wavelength > MB3.band - 0.5 * MB.bandwidth & wavelength < MB3.band + 0.5 * MB.bandwidth) %>%
              select(k) %>% unlist(use.names=F) %>% mean() %>% signif(3), "+-",
           abs.coeff %>% filter(dye == "MB") %>% filter(solution == "H2O+EtOH") %>%
              filter(wavelength > MB3.band - 0.5 * MB.bandwidth & wavelength < MB3.band + 0.5 * MB.bandwidth) %>%
              select(k) %>% unlist(use.names=F) %>% sd() %>% signif(3)))
@


<<'0512P-oxygen-concentration-in-water'>>=
# Hitchman, "Measurement of dissolved oxygen" (1978)
temperature <- 20
oxsolubility <- OxygenSolubilityWater(temperature)
@


<<'0512P-cutoffs'>>=
# these cutoffs are going to have to be defined manually
# these limits are used in plots and subplots below
cutoffs <-
   data.frame(
      structure(dimnames =
                   list(
                      # rownames
                      c(),
                      # colnames
                      c( "sample",             "bandgap", "diameter", "k1", "k2")),
                matrix(c("N02A-small-nostir",   150,       130,         20,  21,
                         "N04H-small-nostir",   140,       140,         20,  21,
                         "N04H-medium-nostir",   40,        40,         20,  45,
                         "N02A-large-nostir",    29,        29,         20,  35,
                         "N04E-large-nostir",    18,        18,         20,  35),
                       ncol = 5, byrow = T)))
cutoffs %<>%
   mutate(bandgap = as.numeric(bandgap)) %>%
   mutate(diameter = as.numeric(diameter)) %>%
   mutate(k1 = as.numeric(k1)) %>%
   mutate(k2 = as.numeric(k2))
# Limits set to NA mean that no cutoff is imposed on the data (it simply runs to its natural end)
# Cutoffs are necessary for bandgap and diameter because parametrising the goodness of an Eg linear fit
# is excessively hard to do, but a visual inspection will quickly tell whether the fit is reasonable.
# The limits above are the result of such ocular optimisation.
# k1 and k2 are the last and initial cutoffs for the k1 and k2 rates, respectively.
# used like this: from 0 to k1, and from k2 to last time in dataset.
# N02A-small-nostir    75,  NA
# N04H-small-nostir,  100,  NA
# N04H-medium-nostir   17,  48
# N02A-large-nostir    20,  33
# N04E-large-nostir    18,  40

# spectrometer instrument resolution 1.5 nm, here converted to eV roughly at the band edge
spectrometer.resolution <-
   wavelength2energy(354) - wavelength2energy(355.5)
@





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% small NP (PS data)
%%% NP initial size: SMALL
%%% NO STIRRING

<<'0512P-read-N04H-small-nostir'>>=
pc.abs.small.N04H.nostir <-
   LoadRData2Variable(here::here("assets/data/P12/PC/abs-pc-spectra-N04H-small-nostir.rda.gz")) %>%
   filter(intensity >= 0) %>%
   filter(wavelength >= 285 & wavelength <= 1050)
# add time and adjusted time to df
# time can be constructed by reading the five last digits of sampleid
# time.abs is the time (in minutes) since the first abs measurement
pc.abs.small.N04H.nostir$time.abs <-
   as.numeric(gsub("^N04H-", "", pc.abs.small.N04H.nostir$sampleid))
# time.exp is the time (in minutes) since the mixing of the precursors
pc.abs.small.N04H.nostir$time.exp <-
   pc.abs.small.N04H.nostir$time.abs + 0 # not corrected
# express wavelength as energy (convert nm to eV)
pc.abs.small.N04H.nostir$eV <-
   wavelength2energy(pc.abs.small.N04H.nostir$wavelength)
# square the measured abs (without any correction for negative values)
pc.abs.small.N04H.nostir$sqabs <-
   pc.abs.small.N04H.nostir$intensity^2
# saved spectra no. in its own column (split it off from sampleid string)
pc.abs.small.N04H.nostir$spectra <-
   as.numeric(sub("^N04H-", "", pc.abs.small.N04H.nostir$sampleid))
# add a fitted = {TRUE or FALSE} column to pc.abs.small.N04H.nostir
pc.abs.small.N04H.nostir$fitted <- FALSE
@

<<'0512P-NPBE-N04H-small-nostir-photodegradation-fit-bandgap'>>=
# the band edge eventually flattens out
edge.time.cutoff <- subset(cutoffs, sample == "N04H-small-nostir")$bandgap
# Limit data to eV range of interest
# also, ceiling should end before it intersects with the floors
E.range.floor <- c(2.8, max(pc.abs.small.N04H.nostir$eV))
E.range.ceiling <- c(3.4, max(pc.abs.small.N04H.nostir$eV))
# Note that E.range.floor encompasses E.range.ceiling (by design)
floor.pc.abs.small.N04H.nostir <-
   pc.abs.small.N04H.nostir %>%
   filter(spectra <= edge.time.cutoff) %>%
   filter(eV >= min(E.range.floor) & eV <= max(E.range.floor))
ceiling.pc.abs.small.N04H.nostir <-
   pc.abs.small.N04H.nostir %>%
   filter(spectra <= edge.time.cutoff) %>%
   filter(eV >= min(E.range.ceiling) & eV <= max(E.range.ceiling))
@

<<'0512P-NPBE-N04H-small-nostir-photodegradation-energy-ceiling'>>=
# note, we only need one sampleid in ceiling (we are using the same ceiling for all spectra)
sqabs.ceiling <-
   data.frame(eV = seq(max(E.range.ceiling), min(E.range.ceiling),
                       length.out = length(subset(ceiling.pc.abs.small.N04H.nostir,
                                                  sampleid == unique(ceiling.pc.abs.small.N04H.nostir$sampleid)[1])$eV)))
# the two numbers below set the slope of the ceiling
sqabs.ceiling$sqabs <-
   # these two values should be adjusted if edge.time.cutoff is changed
   seq(5.2, 1.7, length.out = length(sqabs.ceiling$eV))
@

<<'0512P-NPBE-N04H-small-nostir-photodegradation-max-sqabs-ceiling-floor', warning=FALSE>>=
# upper and lower bounds for linear fit (squared abs, intersect with abscissa determines bandgap)
bg.fit.upper <- 0.7 # 0.8 * (ceiling - floor)
bg.fit.lower <- 0.2 # 0.3 * (ceiling - floor)
# make a condensed df (one row per sampleid, ie one row per spectrum)
condensed.abs.small.N04H.nostir <- data.frame(sampleid = unique(pc.abs.small.N04H.nostir$sampleid))
condensed.abs.small.N04H.nostir$spectra <- as.numeric(sub("^N04H-", "", condensed.abs.small.N04H.nostir$sampleid))
condensed.abs.small.N04H.nostir$time.abs <- unique(pc.abs.small.N04H.nostir$time.abs)
condensed.abs.small.N04H.nostir$time.exp <- unique(pc.abs.small.N04H.nostir$time.exp)
condensed.abs.small.N04H.nostir$sqabs.ceiling.x <- NA
condensed.abs.small.N04H.nostir$sqabs.ceiling.y <- NA
condensed.abs.small.N04H.nostir$sqabs.floor.x <- NA
condensed.abs.small.N04H.nostir$sqabs.floor.y <- NA
condensed.abs.small.N04H.nostir$interv.high.y <- NA
condensed.abs.small.N04H.nostir$interv.low.y <- NA
# calculated optical band gap and associated parameters
condensed.abs.small.N04H.nostir$fit.Eg <- set_errors(NA, NA)
condensed.abs.small.N04H.nostir$fit.adj.rsq <- NA
condensed.abs.small.N04H.nostir$fit.points <- NA
condensed.abs.small.N04H.nostir$fit.slope <- set_errors(NA, NA)
# absorbance at MB max peak
condensed.abs.small.N04H.nostir$abs.MB.max <- set_errors(NA, NA)
# estimate the "floor" of the bandgap by fitting a linear function to _each_ spectrum
# set the range within which each spectrum appears linear
edge.floor.fitrange <- c(min(E.range.floor), min(E.range.ceiling))
floor.pc.abs.small.N04H.nostir$sqabs.floor <- as.numeric(NA)
# a temporary variable, for collecting sqabs.floor vectors inside the loop
floors.sqabs <- NULL
# temporary variable to hold the "fitted" TRUE/FALSE vectors
points.fitted <- NULL
#
for (s in 1:length(condensed.abs.small.N04H.nostir$sampleid)) {
   # message("s = ", s)
   # mean abs in the bandwidth centered on the MB abs max peak, using sd() as error
   condensed.abs.small.N04H.nostir$abs.MB.max[s] <-
      set_errors(subset(pc.abs.small.N04H.nostir, sampleid == unique(pc.abs.small.N04H.nostir$sampleid)[s]) %>%
                    filter(wavelength > MB.band - 0.5 * MB.bandwidth & wavelength < MB.band + 0.5 * MB.bandwidth) %>%
                    select(intensity) %>%
                    unlist(use.names = F) %>%
                    mean(),
                 subset(pc.abs.small.N04H.nostir, sampleid == unique(pc.abs.small.N04H.nostir$sampleid)[s]) %>%
                    filter(wavelength > MB.band - 0.5 * MB.bandwidth & wavelength < MB.band + 0.5 * MB.bandwidth) %>%
                    select(intensity) %>%
                    unlist(use.names = F) %>%
                    sd())
   # linear fit floor
   this.floor <-
      subset(pc.abs.small.N04H.nostir,
             sampleid == unique(pc.abs.small.N04H.nostir$sampleid)[s])
   # message("sampleid = ", unique(pc.abs.small.N04H.nostir$sampleid)[s])
   lm.this.floor <-
      lm(formula = sqabs ~ eV,
         data = subset(this.floor, (eV >= min(edge.floor.fitrange) & eV <= max(edge.floor.fitrange))))
   this.floor.intercept <- lm.this.floor$coefficients[1]
   this.floor.slope <- lm.this.floor$coefficients[2]
   this.floor$sqabs.floor <- this.floor.slope * this.floor$eV + this.floor.intercept
   # just book-keeping: appending to vector...
   floors.sqabs <- c(floors.sqabs, this.floor$sqabs.floor)
   # if-clause to write NA's if we are past the length of the ceiling vector
   # this is because the edge.time.cutoff setting limits the number of spectra that get ceilings
   # (all spectra at s > edge.time.cutoff + 1 should respect this setting and not have ceilings)
   if (s > edge.time.cutoff + 1) {
      condensed.abs.small.N04H.nostir$sqabs.ceiling.y[s] <-
         condensed.abs.small.N04H.nostir$sqabs.ceiling.x[s] <- NA
   } else {
      # find the energy value where sqabs reaches zero,
      # or else the energy value corresponding to minimum sqabs
      this.spectrum.ceiling <-
         ceiling.pc.abs.small.N04H.nostir[which(ceiling.pc.abs.small.N04H.nostir$sampleid ==
                                            condensed.abs.small.N04H.nostir$sampleid[s]), ]
      # message(paste0("dim(this.spectrum.ceiling)[1] = ", dim(this.spectrum.ceiling)[1]))
      # check each point: if above the sloping maxline (green line in plot), write TRUE to "above"
      above.ceiling <- this.spectrum.ceiling$sqabs > sqabs.ceiling$sqabs
      # issue a warning if none of the points lie above the maxline as expected (not a given)
      if (!any(above.ceiling == TRUE)) {warning("No datapoints above ceiling for s = ", s)}
      # points always intersect when above=TRUE, then FALSE or vice versa
      # there may be more than one intersect (e.g., the spectrum can go up over the line,
      # then dip below it, and go over it again, etc.
      # Therefore, only consider the _last_ intersection point (remember, the x-scale is flipped)
      intersect.point <- which(diff(above.ceiling) != 0)[length(which(diff(above.ceiling) != 0))]
      # max sqabs:
      condensed.abs.small.N04H.nostir$sqabs.ceiling.y[s] <- this.spectrum.ceiling$sqabs[intersect.point]
      # corresponding energy value for max sqabs:
      # (we only need this x-value for plotting the points below, and not for bandgap calc)
      condensed.abs.small.N04H.nostir$sqabs.ceiling.x[s] <- this.spectrum.ceiling$eV[intersect.point]
   }
   ### find floor (note: this is more complicated than ceiling, because each spectrum
   ### is compared against its own floor
   ### But we don't need to worry about edge.time.cutoff, as the floor is always defined
   this.spectrum.floor <- this.floor
   # index 1 of eV scale is the largest value in eV, index last is the smallest value
   # at which indices is the observed curve _below_ the fitted floor?
   # (ps. this is the only place where we use the linearly fitted floor)
   above.floor <- this.spectrum.floor$sqabs > this.spectrum.floor$sqabs.floor
   # the first TRUE followed by FALSE is a good approx of the intersection point
   # issue a warning if none of the points lie above the floor as expected (not a given)
   if (!any(above.floor == TRUE)) {warning("No datapoint above floor for s = ", s)}
   # the intersection of interest would be the right-most (first in df)
   intersect.point <- which(diff(above.floor) != 0)[1]
   condensed.abs.small.N04H.nostir$sqabs.floor.y[s] <- this.spectrum.floor$sqabs[intersect.point]
   condensed.abs.small.N04H.nostir$sqabs.floor.x[s] <- this.spectrum.floor$eV[intersect.point]
   # set interval higher limit based on ceiling and floor (we only need y-values for this)
   # note: result becomes NA if ceiling.y[s] is NA
   condensed.abs.small.N04H.nostir$interv.high.y[s] <-
      bg.fit.upper * (condensed.abs.small.N04H.nostir$sqabs.ceiling.y[s] - condensed.abs.small.N04H.nostir$sqabs.floor.y[s])
   # set interval lower limit based on ceiling and floor (we only need y-values for this)
   # note: result becomes NA if ceiling.y[s] is NA
   condensed.abs.small.N04H.nostir$interv.low.y[s] <-
      bg.fit.lower * (condensed.abs.small.N04H.nostir$sqabs.ceiling.y[s] - condensed.abs.small.N04H.nostir$sqabs.floor.y[s])
   if (s > edge.time.cutoff + 1) {
      # fill this row with NA's if we're above edge.time.cutoff
      condensed.abs.small.N04H.nostir$fit.Eg[s] <-
         condensed.abs.small.N04H.nostir$fit.slope[s] <-
         condensed.abs.small.N04H.nostir$fit.adj.rsq[s] <-
         condensed.abs.small.N04H.nostir$fit.points[s] <- NA
   } else {
      ### here we do the linear fit to the band edge for each spectrum
      # for the current spectrum, sampleid[s], change "fitted" to TRUE for points *inside* the interval
      this.spectrum.ceiling$fitted[
         which((this.spectrum.ceiling$sqabs <= condensed.abs.small.N04H.nostir$interv.high.y[s]) &
                  (this.spectrum.ceiling$sqabs >= condensed.abs.small.N04H.nostir$interv.low.y[s]))] <- TRUE
      # append "fitted" vector from this.spectrum with all previous ones
      points.fitted <-
         rbind(points.fitted,
               # sampleid column here not necessary, but helps with bug-fixing
               data.frame(sampleid = this.spectrum.ceiling$sampleid,
                          fitted = this.spectrum.ceiling$fitted))
      # CALCULATE LM PARAMS FOR BAND GAP LINEAR FIT FOR THIS SPECTRUM
      # NOTE: Two times the standard error is usually approximated as the 95% confidence level,
      #       but that error is not really what I am after here.
      #       In any case, the standard error should be smaller than the standard deviation,
      #       and so I will go with it as-is.
      this.fit <-
         lm(sqabs ~ eV, data = subset(this.spectrum.ceiling, fitted == TRUE))
      # x-intercept of fitted line, with error (aka the band gap)
      condensed.abs.small.N04H.nostir$fit.Eg[s] <-
         # Eg = -b / k
         set_errors(-summary(this.fit)$coef[1,1], summary(this.fit)$coef[1,2]) /
         set_errors(summary(this.fit)$coef[2,1], summary(this.fit)$coef[2,2])
      # reset the error to the instrumental resolution
      errors(condensed.abs.small.N04H.nostir$fit.Eg[s]) <- spectrometer.resolution
      # slope of fitted line, with error
      condensed.abs.small.N04H.nostir$fit.slope[s] <-
         set_errors(summary(this.fit)$coef[2,1], summary(this.fit)$coef[2,2])
      # adjusted R-square of fit
      condensed.abs.small.N04H.nostir$fit.adj.rsq[s] <- summary(this.fit)$adj.r.squared
      # number of datapoints used for linear fit
      condensed.abs.small.N04H.nostir$fit.points[s] <-
         length(subset(this.spectrum.ceiling, fitted == TRUE)$eV)
   }
}
pc.abs.small.N04H.nostir$sqabs.floor <- floors.sqabs
ceiling.pc.abs.small.N04H.nostir$fitted <- points.fitted$fitted
# calculate concentration (mol/L) from observed Abs and absorption coefficient at MB max wavelength
condensed.abs.small.N04H.nostir$conc.MB <-
   condensed.abs.small.N04H.nostir$abs.MB.max / abs.coeff.MB.max
condensed.abs.small.N04H.nostir$conc.ratio <-
   condensed.abs.small.N04H.nostir$conc.MB / condensed.abs.small.N04H.nostir$conc.MB[1]
# calculate NP diameter, surface area, and volume (assuming sphere)
condensed.abs.small.N04H.nostir$fit.np.diam <-
   diameter(condensed.abs.small.N04H.nostir$fit.Eg, sc = "ZnO",
            # set chosen relative error for parameters a, b, c
            a = set_errors(3.940, 0.05 * 3.940),
            b = set_errors(0.293, 0.05 * 0.293),
            c = set_errors(3.30, 0))
# Above line produces warning messages:
# 1: In '<' : boolean operators not defined for 'errors' objects, uncertainty dropped
# 2: In 'Ops' : non-'errors' operand automatically coerced to an 'errors' object with no uncertainty
condensed.abs.small.N04H.nostir$fit.np.area <-
   pi * condensed.abs.small.N04H.nostir$fit.np.diam^2
condensed.abs.small.N04H.nostir$fit.np.vol <-
   (1/6) * pi * condensed.abs.small.N04H.nostir$fit.np.diam^3
@


<<'0512P-MB-N04H-small-nostir-fityk-script', eval=FALSE, echo=FALSE>>=
spectra <-
   data.frame(
      files = list.files(
         path = here::here("assets/data/P12/PC/PC_MB_N04H_small_nostir_170710"),
         pattern = "^PC_N04H_small_nostir_170710.*\\.txt$",
         full.names = TRUE))
spectra$number <- seq(0, length(spectra$files) - 1)
spectra$fityk.read <- paste0("@+ < '", spectra$files, "'")
spectra$fityk.read[1] <- paste0("@0 < '", spectra$files[1], "'")
# use it like this: cat(spectra$fityk.read, sep="\n")
# only the methylene blue absorption band should be "active", inactivate the rest
spectra$fityk.inactivate <-
   paste0("@*: A = a and not (801.4 < x and x < 1126.2); A = a and not (141.6 < x and x < 500.1)")
# use it like this: cat(unique(spectra$fityk.inactivate), sep="\n")
spectra$bg.x1 <- 503.53 # nm <== @*: = F:calculate_expr("x[678]")
spectra$bg.x2 <- 727.39 # nm <== @*: = F:calculate_expr("x[1177]")
spectra$bg.x3 <- 793.24 # nm <== @*: = F:calculate_expr("x[1327]")
# get the y-value for each x in the same manner, except the value is not constant across spectra
spectra$bg.y1 <- # Abs <== @*: = F:calculate_expr("y[678]")
   c(0.044,0.045,0.046,0.046,0.047,0.047,0.049,0.048,0.049,0.052,0.052,0.053,0.056,0.057,0.058,0.06,0.061,0.062,0.066,0.068,0.071,0.074,0.079,0.083,0.088,0.091,0.097,0.098,0.101,0.104,0.107,0.107,0.11,0.111,0.113,0.115,0.116,0.117,0.118,0.119,0.122,0.122,0.125,0.125,0.127,0.13,0.129,0.132,0.134,0.136,0.138,0.141,0.145,0.145,0.146,0.151,0.152,0.151,0.156,0.157,0.161,0.161,0.165,0.168,0.167,0.172,0.174,0.177,0.178,0.18,0.183,0.184,0.186,0.189,0.191,0.193,0.195,0.195,0.199,0.199,0.201,0.203,0.203,0.209,0.209,0.211,0.211,0.214,0.218,0.219,0.221,0.222,0.223,0.224,0.224,0.227,0.23,0.232,0.233,0.236,0.236,0.238,0.24,0.241,0.244,0.246,0.248,0.248,0.249,0.253,0.255,0.255,0.256,0.256,0.257,0.26,0.261,0.259,0.265,0.266,0.266,0.268,0.269,0.267,0.272,0.271,0.273,0.273,0.27,0.273,0.276,0.276,0.278,0.278,0.279,0.278,0.279,0.279,0.28,0.283,0.283)
spectra$bg.y2 <- # Abs <== @*: = F:calculate_expr("y[1177]")
   c(0.024,0.025,0.026,0.024,0.026,0.025,0.029,0.027,0.026,0.026,0.026,0.026,0.029,0.027,0.029,0.029,0.032,0.031,0.033,0.035,0.036,0.037,0.04,0.039,0.042,0.044,0.046,0.05,0.047,0.051,0.051,0.053,0.055,0.056,0.054,0.058,0.056,0.056,0.057,0.058,0.058,0.061,0.061,0.064,0.062,0.065,0.064,0.067,0.066,0.068,0.068,0.073,0.071,0.074,0.074,0.077,0.076,0.076,0.077,0.077,0.079,0.081,0.08,0.083,0.084,0.086,0.086,0.085,0.09,0.092,0.09,0.094,0.094,0.094,0.095,0.095,0.096,0.098,0.099,0.101,0.101,0.101,0.104,0.103,0.105,0.105,0.108,0.11,0.109,0.108,0.112,0.11,0.114,0.113,0.114,0.114,0.116,0.116,0.117,0.118,0.12,0.121,0.121,0.122,0.125,0.123,0.127,0.123,0.125,0.126,0.127,0.129,0.131,0.129,0.132,0.131,0.131,0.128,0.134,0.134,0.133,0.133,0.134,0.135,0.136,0.138,0.137,0.136,0.133,0.138,0.139,0.14,0.14,0.139,0.139,0.138,0.14,0.143,0.141,0.142,0.144)
spectra$bg.y3 <- # Abs <== @*: = F:calculate_expr("y[1327]")
   c(0.021,0.02,0.021,0.022,0.021,0.021,0.023,0.024,0.022,0.025,0.02,0.024,0.024,0.025,0.024,0.025,0.024,0.027,0.027,0.032,0.027,0.027,0.03,0.035,0.035,0.04,0.037,0.04,0.04,0.042,0.043,0.045,0.044,0.046,0.049,0.048,0.052,0.05,0.05,0.048,0.05,0.052,0.053,0.051,0.051,0.057,0.058,0.058,0.057,0.057,0.059,0.062,0.064,0.062,0.062,0.064,0.06,0.065,0.065,0.069,0.07,0.067,0.07,0.067,0.068,0.072,0.074,0.076,0.075,0.08,0.076,0.076,0.082,0.081,0.081,0.082,0.082,0.083,0.086,0.086,0.087,0.09,0.086,0.089,0.091,0.091,0.092,0.095,0.095,0.095,0.093,0.098,0.095,0.099,0.096,0.1,0.1,0.099,0.1,0.1,0.104,0.105,0.106,0.107,0.106,0.106,0.103,0.11,0.108,0.113,0.11,0.109,0.11,0.11,0.112,0.11,0.111,0.114,0.112,0.111,0.114,0.116,0.115,0.111,0.115,0.118,0.117,0.117,0.116,0.117,0.123,0.121,0.119,0.12,0.122,0.121,0.122,0.121,0.124,0.121,0.121)
# now generate the fityk background string
spectra$fit.bg <-
   paste0("%bg", spectra$number, " = Spline(",
          spectra$bg.x1, ",",
          spectra$bg.y1, ", ",
          spectra$bg.x2, ",",
          spectra$bg.y2, ", ",
          spectra$bg.x3, ",",
          spectra$bg.y3, ")")
# use it like this: cat(spectra$fit.bg, sep="\n")
# now the fityk string to actually apply each bg
spectra$remove.bg <-
   paste0("@", spectra$number, ": ",
          "Y = y - %bg", spectra$number, "(x)")
# use it like this: cat(spectra$remove.bg, sep="\n")
# now place the initial kernels (the same for all spectra)
spectra$create.kernels <-
   paste0("@*: ",
          "F += Gaussian(height=~0.50, center=~666, hwhm=~16)", "; ",
          "F += Gaussian(height=~0.25, center=~628, hwhm=~32)")
# use it like this: cat(unique(spectra$create.kernels))
# and now we fit, all spectra in one go (this might take a few minutes, depending on CPU and # spectra)
spectra$fit <- "@*: fit"
# For each dataset write output of the info peaks command to a file named after the data file
# @*: lua F:execute("info peaks > '%s.peaks'" % F:get_info("filename")) # drawback: .txt.peaks extension
spectra$print.peaks <-
   paste0("@", spectra$number, ": ",
          "info peaks > '", sub("\\.txt$", ".peaks", spectra$files), "'")
# use it like this: cat(spectra$print.peaks, sep = "\n")
# For each dataset write output of the info confidence command to a file named after the data file
# @*: lua F:execute("info confidence 95 > '%s.errors'" % F:get_info("filename"))
spectra$print.errors <-
   paste0("@", spectra$number, ": ",
          "info confidence 95 > '", sub("\\.txt$", ".errors", spectra$files), "'")
# use it like this: cat(spectra$print.errors, sep = "\n")
# print the full dataset (with obs, function, bg and so on) in case you want to recreate the plots
spectra$print.data <-
   paste0("@", spectra$number, ": ",
          "print if a: x, y, a, F(x), y-F(x) > '",
          sub("\\.txt$", ".dat", spectra$files), "'")
# use it like this: cat(spectra$print.data, sep = "\n")
# Finally, you may want to save the complete Fityk session state (very large ASCII file)
spectra$save.session <-
   paste0(
      "info state > '",
      here::here("assets/data/P12/PC/session-N04H-small.fit"),
      "'")
@


<<'0512P-MB-N04H-small-nostir-fityk-errors', warning=FALSE>>=
if (!file.exists(here::here("assets/data/P12/PC/MB-N04H-small-fityk-errors.rda.gz"))) {
   fityk.files <-
      list.files(
         path = here::here("assets/data/P12/PC/PC_MB_N04H_small_nostir_170710"),
         pattern = "*.errors",
         full.names = TRUE)
   fityk.errors.small.N04H.nostir.MB.max <- NULL
   for (i in 1:length(fityk.files)) {
      this.df <-
         read.table(fityk.files[i], skip = 1, sep = "=") %>%
         # drop the redundant first column
         select(-V1) %>%
         # replace the "+-" separator with a single character so we can use separate()
         mutate(V2 = sub(" +- ", ",", V2, fixed = TRUE)) %>%
         separate(V2, sep = ",", into = c("value", "error")) %>%
         # make sure value and error columns are numeric
         mutate(value = as.numeric(value)) %>%
         # this introduces NAs by coercion, throws warning
         mutate(error = as.numeric(error)) %>%
         mutate(property = rep(c("height", "center", "hwhm"), 2)) %>%
         mutate(peak = c(rep(1, 3), rep(2, 3))) %>%
         mutate(spectra = basename(fityk.files[i]) %>%
                   sub(x=., "\\.errors", "") %>%
                   sub(x=., "PC_N04H_small_nostir_170710_", "") %>%
                   as.numeric())
      fityk.errors.small.N04H.nostir.MB.max <-
         rbind(fityk.errors.small.N04H.nostir.MB.max,
               this.df)
   }
   # Warning message inside loop:
   # There was 1 warning in `mutate()`.
   # ℹ In argument: `error = as.numeric(error)`.
   # Caused by warning:
   # ! NAs introduced by coercion
   fityk.errors.small.N04H.nostir.MB.max <-
      fityk.errors.small.N04H.nostir.MB.max %>%
      filter(property == "height")
   # since the peak fitting as automatic, a few fits are nonsense
   # so replace any error that is larger than its value by NA
   fityk.errors.small.N04H.nostir.MB.max$error[which(fityk.errors.small.N04H.nostir.MB.max$error > fityk.errors.small.N04H.nostir.MB.max$value)] <- NA
   save(
      fityk.errors.small.N04H.nostir.MB.max,
      file = here::here("assets/data/P12/PC/MB-N04H-small-fityk-errors.rda.gz"),
      compress = "gzip")
} else {
   fityk.errors.small.N04H.nostir.MB.max <- common::LoadRData2Variable(
      path = here::here("assets/data/P12/PC/MB-N04H-small-fityk-errors.rda.gz"))
}
@


<<'0512P-MB-N04H-small-nostir-fityk-peaks', warning=FALSE>>=
if (!file.exists(here::here("assets/data/P12/PC/MB-N04H-small-fityk-peaks.rda.gz"))) {
   fityk.files <-
      list.files(
         path = here::here("assets/data/P12/PC/PC_MB_N04H_small_nostir_170710"),
         pattern = "*.peaks",
         full.names = TRUE)
   fityk.peaks.small.N04H.nostir.MB.max <- NULL
   for (i in 1:length(fityk.files)) {
      fityk.peaks.small.N04H.nostir.MB.max <-
         rbind(fityk.peaks.small.N04H.nostir.MB.max,
               cbind(spectra = as.numeric(sub("PC_N04H_small_nostir_170710_", "",
                                              sub("\\.peaks", "", basename(fityk.files[i])))),
                     read.table(fityk.files[i],
                                skip = 1,
                                # skip the last three columns (fityk's output is verbose)
                                colClasses = c(rep(NA, 6), rep("NULL", 3)),
                                col.names = c("peak", "type", "center", "height", "area", "fwhm",
                                              "", "", ""))))
   }
   # drop visual outliers
   fityk.peaks.small.N04H.nostir.MB.max <-
      fityk.peaks.small.N04H.nostir.MB.max[
         -which(fityk.peaks.small.N04H.nostir.MB.max$spectra > 110 &
                   fityk.peaks.small.N04H.nostir.MB.max$height > 0.1), ]
   fityk.peaks.small.N04H.nostir.MB.max$peakno <-
      as.numeric(sub("%_", "", fityk.peaks.small.N04H.nostir.MB.max$peak))
   # calculate concentration (mol/L) from fitted height
   fityk.peaks.small.N04H.nostir.MB.max$conc.MB <-
      fityk.peaks.small.N04H.nostir.MB.max$height / abs.coeff.MB.max
   # Above line throws warning messages:
   # 1: In idyid * dy :
   #   longer object length is not a multiple of shorter object length
   # 2: In idyid * dy :
   #   longer object length is not a multiple of shorter object length
   # calculate C/C0
   fityk.peaks.small.N04H.nostir.MB.max$conc.ratio <-
      fityk.peaks.small.N04H.nostir.MB.max$conc.MB / fityk.peaks.small.N04H.nostir.MB.max$conc.MB[1]
   # join height error from errors into this df
   fityk.peaks.small.N04H.nostir.MB.max <-
      left_join(fityk.peaks.small.N04H.nostir.MB.max,
                fityk.errors.small.N04H.nostir.MB.max %>% select(value, error),
                by = c("height" = "value")) %>%
      rename(height.error = error)
   # set_error in the height column itself and drop height.error column
   fityk.peaks.small.N04H.nostir.MB.max$height <-
      set_errors(fityk.peaks.small.N04H.nostir.MB.max$height,
                 fityk.peaks.small.N04H.nostir.MB.max$height.error)
   fityk.peaks.small.N04H.nostir.MB.max <-
      fityk.peaks.small.N04H.nostir.MB.max %>% select(-height.error)
   save(
      fityk.peaks.small.N04H.nostir.MB.max,
      file = here::here("assets/data/P12/PC/MB-N04H-small-fityk-peaks.rda.gz"),
      compress = "gzip")
} else {
   fityk.peaks.small.N04H.nostir.MB.max <- common::LoadRData2Variable(
      path = here::here("assets/data/P12/PC/MB-N04H-small-fityk-peaks.rda.gz"))
}

@


<<'0512P-figref-MB-N04H-small-nostir-photodegradation', eval=FALSE>>=
nth.spectra <- 1
this.data <-
   pc.abs.small.N04H.nostir %>%
   filter(time.abs %in% seq(0, length(unique(pc.abs.small.N04H.nostir$time.abs)), by = nth.spectra))
this.condensed <- condensed.abs.small.N04H.nostir
this.ceiling <- ceiling.pc.abs.small.N04H.nostir
this.fityk <- fityk.peaks.small.N04H.nostir.MB.max
# :: this plot includes every nth spectra (if n = 1 above then every spectra is included)
p <-
   ggplot() +
   ### TAUC ANALYSIS
   ## highlight of MB abs peak
   geom_rect(aes(xmin = wavelength2energy(MB.band - 0.5 * MB.bandwidth),
                 xmax = wavelength2energy(MB.band + 0.5 * MB.bandwidth)),
             ymin = 0,
             ymax = 0.8,
             fill = "#F9BC00",
             colour = "#0B096C") +
   ## Line segments that help the reader to connect the bandgap inset
   geom_curve(aes(x = max(this.condensed$fit.Eg, na.rm=T),
                  y = 0,
                  xend = 2.9,
                  yend = 1.85),
              curvature = 0.5,
              angle = 90,
              ncp = 5,
              linetype = "dashed",
              colour = alpha("gray30", 0.6)) +
   geom_curve(aes(x = min(this.condensed$fit.Eg, na.rm=T),
                  y = 0,
                  xend = 2.9,
                  yend = 0.55),
              curvature = 0.52,
              angle = 90,
              ncp = 5,
              linetype = "dashed",
              colour = alpha("gray30", 0.6)) +
   ## Line segments that help the reader to connect the MB inset
   geom_curve(aes(x = wavelength2energy(MB.band + 0.5 * MB.bandwidth),
                  y = 0,
                  xend = 2,
                  yend = 3.68),
              curvature = -0.5,
              angle = 90,
              ncp = 5,
              linetype = "dashed",
              colour = alpha("gray30", 0.6)) +
   geom_curve(aes(x = wavelength2energy(MB.band + 0.5 * MB.bandwidth),
                  y = 0.65,
                  xend = 2,
                  yend = 6.92),
              curvature = -0.75,
              angle = 90,
              ncp = 5,
              linetype = "dashed",
              colour = alpha("gray30", 0.6)) +
   ## MAIN DATA
   geom_line(data = this.data,
             aes(x = eV,
                 y = sqabs,
                 group = sampleid,
                 colour = time.exp,
                 alpha = -time.exp)) +
   ## highlight first spectrum
   geom_line(data = this.data %>%
                filter(spectra == 0),
             aes(x = eV, # wavelength,
                 y = sqabs), # intensity),
             colour = alpha("red", 0.75)) +
   ## highlight last spectrum
   geom_line(data = this.data %>%
                filter(spectra == max(spectra)),
             aes(x = eV, # wavelength,
                 y = sqabs), #intensity),
             colour = alpha("red", 0.75)) +
   ## highlight Tauc lines intersecting with x-axis
   ## drawn *behind* the linear fits
   geom_segment(aes(x = min(this.condensed$fit.Eg, na.rm=T),
                    xend = max(this.condensed$fit.Eg, na.rm=T),
                    y = 0,
                    yend = 0),
                # make the line a little thicker
                size = 0.75,
                colour = "#4387BF") +
   ## Tauc linear fits
   geom_smooth(data = subset(this.ceiling, fitted == TRUE),
               aes(x = eV,
                   y = sqabs,
                   group = sampleid),
               method = "lm",
               formula = y ~ x,
               se = FALSE,
               size = 0.2,
               colour = alpha("#D5B450", 0.75),
               linetype = 1,
               fullrange = TRUE) +
   ## labelled arrows showing direction of "time" for bandgaps and MB peak
   geom_segment(aes(x = 4.10, xend = 3.85, #x = 3.75, xend = 3.5,
                    y = 1.1, yend = 1.1),
                arrow = arrow(length = unit(0.015, "npc"))) +
   annotate("text", x = 4.13, y = 1.1, label = "$t$", size = 3.5) +
   geom_segment(aes(x = 1.75, xend = 1.75,
                    y = 0.48, yend = 0.18),
                arrow = arrow(length = unit(0.015, "npc"))) +
   annotate("text", x = 1.755, y = 0.60, label = "$t$", size = 3.5) +
   labs(x = "$E/\\unit{\\eV}$",
        y = "$A^2$") +
   scale_x_continuous(breaks = seq(1, 5, 0.5),
                      sec.axis =
                         sec_axis(~ 1239.842 / .,
                                  name = "$\\lambda/\\unit{\\nm}$")) +
   # Note that sqrt y-axis visually negates sqabs, while keeping the sqabs axis numbering
   scale_y_sqrt(expand = c(0, 0.05),
                breaks = seq(0, 8)) +
   coord_cartesian(xlim = c(1.5, 4.2),
                   ylim = c(0, 7.5)) +
   theme(legend.position = "none")
p.mbabs.fityk <-
   ggplot() +
   geom_errorbar(data = this.fityk %>%
                    filter(this.fityk$peakno %% 2 == 1),
                 colour = alpha("#0B096C", 0.4),
                 size = 0.2,
                 aes(x = spectra,
                     ymin = errors_min(height),
                     ymax = errors_max(height),
                     group = 1)) +
   # first point, highlighted
   geom_point(data = this.fityk %>%
                 filter(this.fityk$peakno %% 2 == 1) %>%
                 filter(spectra == 0),
              size = 1.30,
              colour = alpha("red", 0.30),
              aes(spectra,
                  height)) +
   # last point, highlighted
   geom_point(data = this.fityk %>%
                 filter(this.fityk$peakno %% 2 == 1) %>%
                 filter(spectra == max(spectra)),
              size = 1.30,
              colour = alpha("red", 0.30),
              aes(spectra,
                  height)) +
   geom_line(data = this.fityk %>%
                filter(this.fityk$peakno %% 2 == 1),
             colour = "black",
             size = 0.1,
             aes(spectra,
                 height,
                 group = 1)) +
   # label for LaTeX figure label
   geom_text(aes(label = "\\footnotesize\\itshape (a)",
                 x = this.fityk %>% filter(this.fityk$peakno %% 2 == 1) %>% select(spectra) %>% max(na.rm=T),
                 y = this.fityk %>% filter(this.fityk$peakno %% 2 == 1) %>% select(height) %>% max(na.rm=T)),
             size = 3.8,
             hjust = 1, vjust = 1) +
   labs(x = "$t/\\unit{\\minute}$",
        y = "$A$") +
   theme(legend.position = "none",
         # make area outside panel transparent
         plot.background =
            element_rect(fill = NA,
                         colour = NA))
p.edge <- ggplot() +
   # highlight first point
   geom_point(data = this.condensed %>%
                 filter(spectra == 0),
              size = 1.25,
              colour = alpha("red", 0.30),
              aes(x = spectra,
                  y = fit.Eg)) +
   geom_errorbar(data = this.condensed,
                 size = 0.65,
                 colour = alpha("#4387BF", 0.2),
                 aes(x = spectra,
                     ymin = errors_min(fit.Eg),
                     ymax = errors_max(fit.Eg))) +
   geom_point(data = this.condensed,
              shape = 21,
              size = 0.65,
              fill = "#D5B450",
              colour = "#4387BF",
              aes(x = spectra,
                  y = fit.Eg)) +
   # arrow pointing to scale
   geom_segment(aes(x = 16, xend = 0,
                    y = 3.62, yend = 3.62),
                colour = "#4387BF",
                size = 1,
                arrow = arrow(length = unit(0.050, "npc"))) +
   labs(x = "$t$/\\unit{\\minute}",
        y = "$E_\\text{g}$/\\unit{\\eV}") +
   scale_x_continuous() +
   scale_y_continuous() +
   theme(legend.position = "none",
         # make area outside panel transparent
         plot.background =
            element_rect(fill = NA,
                         colour = NA))
p.edge.diam <- ggplot() +
   geom_errorbar(data = this.condensed %>%
                    filter(spectra <= subset(cutoffs, sample == "N04H-small-nostir")$diameter),
                 size = 0.35,
                 colour = alpha("#D5B450", 0.3),
                 aes(x = spectra,
                     ymin = errors_min(fit.np.diam),
                     ymax = errors_max(fit.np.diam))) +
   geom_point(data = this.condensed %>%
                 filter(spectra <= subset(cutoffs, sample == "N04H-small-nostir")$diameter),
              size = 0.35,
              colour = "#D5B450",
              aes(x = spectra,
                  y = fit.np.diam)) +
   # arrow pointing to scale
   geom_segment(aes(x = 105, xend = 105+25,
                    y = 4.9, yend = 4.9),
                colour = "#D5B450",
                size = 1,
                arrow = arrow(length = unit(0.050, "npc"))) +
   # label for LaTeX figure label
   geom_text(aes(label = "\\footnotesize\\itshape (b)",
                 x = max(this.condensed$spectra, na.rm=T),
                 y = max(this.condensed$fit.np.diam, na.rm=T)),
             size = 3.8,
             hjust = 1, vjust = 1) +
   labs(x = "$t/\\unit{\\minute}$",
        y = "$d/\\unit{\\nm}$") +
   scale_y_continuous(position = "right") +
   scale_x_continuous() +
   coord_cartesian(xlim = c(0, max(this.condensed$spectra))) +
   theme(legend.position = "none",
         # panel.grid.major = element_line(colour = alpha("red", 0.5)),
         # panel.grid.minor = element_line(colour = alpha("red", 0.5)),
         panel.grid = element_blank(),
         axis.title.x = element_blank(),
         axis.text.x = element_blank(),
         axis.ticks.x = element_blank(),
         # make plot background transparent
         panel.background = element_rect(fill = NA, colour = NA),
         # make area outside panel transparent
         plot.background =
            element_rect(fill = NA,
                         colour = NA))
vp.p <- viewport(width = 1, height = 1, x = 0, y = 0, just = c("left", "bottom"))
vp.edge <- viewport(
   width = 0.30, height = 0.30,
   x = 0.25, y = 0.52, #0.55,
   just = c("left", "top"))
vp.edge.diam <- viewport(
   # due to different width of axis text and titles, width needs to be adjusted here
   # due to suppression of x text/title, the height needs to be decreased here
   width = 0.282,
   height = 0.204,
   x = 0.325,
   y = 0.52,
   just = c("left", "top"))
vp.mbabs.fityk <- viewport(
   width = 0.30, height = 0.30,
   x = 0.20, y = 0.55,
   just = c("left", "bottom"))
print(p, vp = vp.p)
print(p.edge, vp = vp.edge)
print(p.edge.diam, vp = vp.edge.diam)
print(p.mbabs.fityk, vp = vp.mbabs.fityk)
@




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% small NP (TA data)
%%% NP initial size: SMALL
%%% NO STIRRING

<<'0512P-read-N02A-small-nostir'>>=
#### N02A # small nanoparticles (initially)
# remove the noisy ends and data points below the abscissa
pc.abs.small.N02A.nostir <-
   LoadRData2Variable(here::here("assets/data/P12/PC/abs-pc-spectra-N02A-small-nostir.rda.gz")) %>%
   filter(intensity >= 0) %>%
   filter(wavelength >= 285 & wavelength <= 1050)
# add time and adjusted time to df
# time can be constructed by reading the five last digits of sampleid
# time.abs is the time (in minutes) since the first abs measurement
pc.abs.small.N02A.nostir$time.abs <- as.numeric(gsub("^N02A-", "", pc.abs.small.N02A.nostir$sampleid))
# time.exp is the time (in minutes) since the mixing of the precursors
pc.abs.small.N02A.nostir$time.exp <- pc.abs.small.N02A.nostir$time.abs + 11
# express wavelength as energy (convert nm to eV)
pc.abs.small.N02A.nostir$eV <- wavelength2energy(pc.abs.small.N02A.nostir$wavelength)
# square the measured abs (without any correction for negative values)
pc.abs.small.N02A.nostir$sqabs <- pc.abs.small.N02A.nostir$intensity^2
# saved spectra no. in its own column (split it off from sampleid string)
pc.abs.small.N02A.nostir$spectra <- as.numeric(sub("^N02A-", "", pc.abs.small.N02A.nostir$sampleid))
# add a fitted = {TRUE or FALSE} column to pc.abs.small.N02A
pc.abs.small.N02A.nostir$fitted <- FALSE
@

<<'0512P-NPBE-N02A-small-nostir-photodegradation-fit-bandgap'>>=
# the band edge eventually flattens out
edge.time.cutoff <- subset(cutoffs, sample == "N02A-small-nostir")$bandgap
# Limit data to eV range of interest
# also, ceiling should end before it intersects with the floors
E.range.floor <- c(2.8, max(pc.abs.small.N02A.nostir$eV))
E.range.ceiling <- c(3.4, max(pc.abs.small.N02A.nostir$eV))
# Note that E.range.floor encompasses E.range.ceiling (by design)
floor.pc.abs.small.N02A.nostir <-
   pc.abs.small.N02A.nostir %>%
   filter(spectra <= edge.time.cutoff) %>%
   filter(eV >= min(E.range.floor) & eV <= max(E.range.floor))
ceiling.pc.abs.small.N02A.nostir <-
   pc.abs.small.N02A.nostir %>%
   filter(spectra <= edge.time.cutoff) %>%
   filter(eV >= min(E.range.ceiling) & eV <= max(E.range.ceiling))
@

<<'0512P-NPBE-N02A-small-nostir-photodegradation-energy-ceiling'>>=
# note, we only need one sampleid in ceiling (we are using the same ceiling for all spectra)
sqabs.ceiling <-
   data.frame(eV = seq(max(E.range.ceiling), min(E.range.ceiling),
                       length.out = length(subset(ceiling.pc.abs.small.N02A.nostir,
                                                  sampleid == unique(ceiling.pc.abs.small.N02A.nostir$sampleid)[1])$eV)))
# the two numbers below set the slope of the ceiling
sqabs.ceiling$sqabs <-
   # these two values should be adjusted if edge.time.cutoff is changed
   seq(6, 1.5, length.out = length(sqabs.ceiling$eV))
@

<<'0512P-NPBE-N02A-small-nostir-photodegradation-max-sqabs-ceiling-floor'>>=
# upper and lower bounds for linear fit (squared abs, intersect with abscissa determines bandgap)
bg.fit.upper <- 0.7 # 0.8 * (ceiling - floor)
bg.fit.lower <- 0.2 # 0.3 * (ceiling - floor)
# make a condensed df (one row per sampleid, ie one row per spectrum)
condensed.abs.small.N02A.nostir <- data.frame(sampleid = unique(pc.abs.small.N02A.nostir$sampleid))
condensed.abs.small.N02A.nostir$spectra <- as.numeric(sub("^N02A-", "", condensed.abs.small.N02A.nostir$sampleid))
condensed.abs.small.N02A.nostir$time.abs <- unique(pc.abs.small.N02A.nostir$time.abs)
condensed.abs.small.N02A.nostir$time.exp <- unique(pc.abs.small.N02A.nostir$time.exp)
condensed.abs.small.N02A.nostir$sqabs.ceiling.x <- NA
condensed.abs.small.N02A.nostir$sqabs.ceiling.y <- NA
condensed.abs.small.N02A.nostir$sqabs.floor.x <- NA
condensed.abs.small.N02A.nostir$sqabs.floor.y <- NA
condensed.abs.small.N02A.nostir$interv.high.y <- NA
condensed.abs.small.N02A.nostir$interv.low.y <- NA
# calculated optical band gap and associated parameters
condensed.abs.small.N02A.nostir$fit.Eg <- set_errors(NA, NA)
condensed.abs.small.N02A.nostir$fit.adj.rsq <- NA
condensed.abs.small.N02A.nostir$fit.points <- NA
condensed.abs.small.N02A.nostir$fit.slope <- set_errors(NA, NA)
# absorbance at MB max peak
condensed.abs.small.N02A.nostir$abs.MB.max <- set_errors(NA, NA)
# estimate the "floor" of the bandgap by fitting a linear function to _each_ spectrum
# set the range within which each spectrum appears linear
edge.floor.fitrange <- c(min(E.range.floor), min(E.range.ceiling))
floor.pc.abs.small.N02A.nostir$sqabs.floor <- as.numeric(NA)
# a temporary variable, for collecting sqabs.floor vectors inside the loop
floors.sqabs <- NULL
# temporary variable to hold the "fitted" TRUE/FALSE vectors
points.fitted <- NULL
#
for (s in 1:length(condensed.abs.small.N02A.nostir$sampleid)) {
   # message("s = ", s)
   # mean abs in the bandwidth centered on the MB abs max peak
   condensed.abs.small.N02A.nostir$abs.MB.max[s] <-
      set_errors(subset(pc.abs.small.N02A.nostir, sampleid == unique(pc.abs.small.N02A.nostir$sampleid)[s]) %>%
                    filter(wavelength > MB.band - 0.5 * MB.bandwidth & wavelength < MB.band + 0.5 * MB.bandwidth) %>%
                    select(intensity) %>%
                    unlist(use.names = F) %>%
                    mean(),
                 subset(pc.abs.small.N02A.nostir, sampleid == unique(pc.abs.small.N02A.nostir$sampleid)[s]) %>%
                    filter(wavelength > MB.band - 0.5 * MB.bandwidth & wavelength < MB.band + 0.5 * MB.bandwidth) %>%
                    select(intensity) %>%
                    unlist(use.names = F) %>%
                    sd())
   # linear fit floor
   this.floor <-
      subset(pc.abs.small.N02A.nostir,
             sampleid == unique(pc.abs.small.N02A.nostir$sampleid)[s])
   # message("sampleid = ", unique(pc.abs.small.N02A.nostir$sampleid)[s])
   lm.this.floor <-
      lm(formula = sqabs ~ eV,
         data = subset(this.floor, (eV >= min(edge.floor.fitrange) & eV <= max(edge.floor.fitrange))))
   this.floor.intercept <- lm.this.floor$coefficients[1]
   this.floor.slope <- lm.this.floor$coefficients[2]
   this.floor$sqabs.floor <- this.floor.slope * this.floor$eV + this.floor.intercept
   # just book-keeping: appending to vector...
   floors.sqabs <- c(floors.sqabs, this.floor$sqabs.floor)
   # if-clause to write NA's if we are past the length of the ceiling vector
   # this is because the edge.time.cutoff setting limits the number of spectra that get ceilings
   # (all spectra at s > edge.time.cutoff + 1 should respect this setting and not have ceilings)
   if (s > edge.time.cutoff + 1) {
      condensed.abs.small.N02A.nostir$sqabs.ceiling.y[s] <-
         condensed.abs.small.N02A.nostir$sqabs.ceiling.x[s] <- NA
   } else {
      # find the energy value where abs reaches zero,
      # or else the energy value corresponding to minimum abs
      this.spectrum.ceiling <-
         ceiling.pc.abs.small.N02A.nostir[which(ceiling.pc.abs.small.N02A.nostir$sampleid ==
                                            condensed.abs.small.N02A.nostir$sampleid[s]), ]
      # message(paste0("dim(this.spectrum.ceiling)[1] = ", dim(this.spectrum.ceiling)[1]))
      # check each point: if above the sloping maxline (green line in plot), write TRUE to "above"
      above.ceiling <- this.spectrum.ceiling$sqabs > sqabs.ceiling$sqabs
      # warn if none of the points lie above the maxline, as expected (not a given)
      if (!any(above.ceiling == TRUE)) {warning("No datapoints above ceiling for s = ", s)}
      # points always intersect when above=TRUE, then FALSE or vice versa
      # there may be more than one intersect (e.g., the spectrum can go up over the line,
      # then dip below it, and go over it again, etc.
      # Therefore, only consider the _last_ intersection point (remember, the x-scale is flipped)
      intersect.point <- which(diff(above.ceiling) != 0)[length(which(diff(above.ceiling) != 0))]
      # max sqabs:
      condensed.abs.small.N02A.nostir$sqabs.ceiling.y[s] <- this.spectrum.ceiling$sqabs[intersect.point]
      # corresponding energy value for max sqabs:
      # (we only need this x-value for plotting the points below, and not for bandgap calc)
      condensed.abs.small.N02A.nostir$sqabs.ceiling.x[s] <- this.spectrum.ceiling$eV[intersect.point]
   }
   ### find floor (note: this is more complicated than ceiling, because each spectrum
   ### is compared against a different floor)
   ### But we don't need to worry about edge.time.cutoff, as the floor is always defined
   this.spectrum.floor <- this.floor
   # index 1 of eV scale is the largest value in eV, index last is the smallest value
   # at which indices is the observed curve _below_ the fitted floor?
   # (ps. this is the only place where we use the linearly fitted floor)
   above.floor <- this.spectrum.floor$sqabs > this.spectrum.floor$sqabs.floor
   # the first TRUE followed by FALSE is a good approx of the intersection point
   # warn if none of the points lie above the floor, as expected (not a given)
   if (!any(above.floor == TRUE)) {warning("No datapoint above floor for s = ", s)}
   # the intersection of interest would be the right-most (first in df)
   intersect.point <- which(diff(above.floor) != 0)[1]
   condensed.abs.small.N02A.nostir$sqabs.floor.y[s] <- this.spectrum.floor$sqabs[intersect.point]
   condensed.abs.small.N02A.nostir$sqabs.floor.x[s] <- this.spectrum.floor$eV[intersect.point]
   # set interval higher limit based on ceiling and floor (we only need y-values for this)
   # note: result becomes NA if ceiling.y[s] is NA
   condensed.abs.small.N02A.nostir$interv.high.y[s] <-
      bg.fit.upper * (condensed.abs.small.N02A.nostir$sqabs.ceiling.y[s] - condensed.abs.small.N02A.nostir$sqabs.floor.y[s])
   # set interval lower limit based on ceiling and floor (we only need y-values for this)
   # note: result becomes NA if ceiling.y[s] is NA
   condensed.abs.small.N02A.nostir$interv.low.y[s] <-
      bg.fit.lower * (condensed.abs.small.N02A.nostir$sqabs.ceiling.y[s] - condensed.abs.small.N02A.nostir$sqabs.floor.y[s])
   if (s > edge.time.cutoff + 1) {
      # fill this row with NA's if we're above edge.time.cutoff
      condensed.abs.small.N02A.nostir$fit.Eg[s] <-
         condensed.abs.small.N02A.nostir$fit.slope[s] <-
         condensed.abs.small.N02A.nostir$fit.adj.rsq[s] <-
         condensed.abs.small.N02A.nostir$fit.points[s] <- NA
   } else {
      ### here we do the linear fit to the band edge for each spectrum
      # for the current spectrum, sampleid[s], change "fitted" to TRUE for points *inside* the interval
      this.spectrum.ceiling$fitted[
         which((this.spectrum.ceiling$sqabs <= condensed.abs.small.N02A.nostir$interv.high.y[s]) &
                  (this.spectrum.ceiling$sqabs >= condensed.abs.small.N02A.nostir$interv.low.y[s]))] <- TRUE
      # append "fitted" vector from this.spectrum with all previous ones
      points.fitted <-
         rbind(points.fitted,
               # sampleid column here not necessary, but helps with bug-fixing
               data.frame(sampleid = this.spectrum.ceiling$sampleid,
                          fitted = this.spectrum.ceiling$fitted))
      # CALCULATE LM PARAMS FOR BAND GAP LINEAR FIT FOR THIS SPECTRUM
      this.fit <-
         lm(sqabs ~ eV, data = subset(this.spectrum.ceiling, fitted == TRUE))
      # x-intercept of fitted line (aka the band gap)
      condensed.abs.small.N02A.nostir$fit.Eg[s] <-
         set_errors(-summary(this.fit)$coef[1,1], summary(this.fit)$coef[1,2]) /
         set_errors(summary(this.fit)$coef[2,1], summary(this.fit)$coef[2,2])
      errors(condensed.abs.small.N02A.nostir$fit.Eg[s]) <- spectrometer.resolution
      # slope of fitted line
      condensed.abs.small.N02A.nostir$fit.slope[s] <-
         set_errors(summary(this.fit)$coef[2,1], summary(this.fit)$coef[2,2])
      # adjusted R squared of fit
      condensed.abs.small.N02A.nostir$fit.adj.rsq[s] <- summary(this.fit)$adj.r.squared
      # number of datapoints used for linear fit
      condensed.abs.small.N02A.nostir$fit.points[s] <- length(subset(this.spectrum.ceiling, fitted == TRUE)$eV)
   }
}
pc.abs.small.N02A.nostir$sqabs.floor <- floors.sqabs
ceiling.pc.abs.small.N02A.nostir$fitted <- points.fitted$fitted
# calculate concentration (mol/L) from observed Abs and absorption coefficient at MB max wavelength
condensed.abs.small.N02A.nostir$conc.MB <-
   condensed.abs.small.N02A.nostir$abs.MB.max / abs.coeff.MB.max
# Above line throws warning messages (I assume it's because RHS uses errors()):
# 1: In idyid * dy :
#   longer object length is not a multiple of shorter object length
# 2: In idyid * dy :
#   longer object length is not a multiple of shorter object length
condensed.abs.small.N02A.nostir$conc.ratio <-
   condensed.abs.small.N02A.nostir$conc.MB / condensed.abs.small.N02A.nostir$conc.MB[1]
# calculate NP diameter, surface area, and volume (assuming sphere)
condensed.abs.small.N02A.nostir$fit.np.diam <-
   diameter(condensed.abs.small.N02A.nostir$fit.Eg, sc = "ZnO",
            a = set_errors(3.940, 0.05 * 3.940),
            b = set_errors(0.293, 0.05 * 0.293),
            c = set_errors(3.30, 0))
condensed.abs.small.N02A.nostir$fit.np.area <- pi * condensed.abs.small.N02A.nostir$fit.np.diam^2
condensed.abs.small.N02A.nostir$fit.np.vol <- (1/6) * pi * condensed.abs.small.N02A.nostir$fit.np.diam^3
@

<<'0512P-MB-N02A-small-nostir-fityk-script', eval=FALSE, echo=FALSE>>=
spectra <-
   data.frame(files =
                 list.files(path = here::here("assets/data/P12/PC/160424-N02A"),
                  pattern = "\\.txt$",
                  full.names = TRUE))
spectra$number <- seq(0, length(spectra$files) - 1)
spectra$fityk.read <- paste0("@+ < '", spectra$files, "'")
spectra$fityk.read[1] <- paste0("@0 < '", spectra$files[1], "'")
# use it like this: cat(spectra$fityk.read, sep="\n")
# only the methylene blue absorption band should be "active", inactivate the rest
spectra$fityk.inactivate <-
   paste0("@*: A = a and not (801.4 < x and x < 1126.2); A = a and not (141.6 < x and x < 500.1)")
# use it like this: cat(unique(spectra$fityk.inactivate), sep="\n")
# stripping the background takes some work, since spectra may shift up/down
# We will use a spline with 3 points at the same x-values for all spectra,
# and then find the corresponding y-values for each point for each spectrum
# And finally use those 3 x,y-coordinates to create each spline function
# x-values at indices: 678, 1177, 1327 (index in vector)
spectra$bg.x1 <- 503.53 # nm <== @*: = F:calculate_expr("x[678]")
spectra$bg.x2 <- 727.39 # nm <== @*: = F:calculate_expr("x[1177]")
spectra$bg.x3 <- 793.24 # nm <== @*: = F:calculate_expr("x[1327]")
# get the y-value for each x in the same manner, except the value is not constant across spectra
spectra$bg.y1 <- # Abs <== @*: = F:calculate_expr("y[678]")
   c(0.047,0.048,0.049,0.05,0.053,0.051,0.051,0.052,0.052,0.055,0.053,0.056,0.058,0.059,0.067,0.071,0.077,0.082,0.085,0.09,0.091,0.093,0.099,0.1,0.101,0.105,0.106,0.108,0.111,0.11,0.111,0.112,0.113,0.116,0.118,0.119,0.123,0.123,0.127,0.129,0.132,0.137,0.138,0.143,0.146,0.144,0.148,0.147,0.154,0.157,0.159,0.162,0.162,0.166,0.168,0.164,0.168,0.173,0.172,0.168,0.173,0.18,0.182,0.182,0.182,0.189,0.19,0.187,0.191,0.193,0.195,0.198,0.201,0.202,0.201,0.21,0.207,0.206,0.218,0.21,0.211,0.221,0.215,0.221,0.222,0.221,0.228,0.224,0.227,0.233,0.232,0.23,0.235,0.234,0.237,0.24,0.239,0.238,0.243,0.245,0.245,0.25,0.248,0.25,0.254,0.249,0.25,0.252,0.251,0.254,0.258,0.255,0.254,0.259,0.256,0.257,0.265,0.264,0.257,0.262,0.263,0.265,0.264,0.264,0.267,0.268,0.269,0.272,0.272,0.273,0.272,0.277,0.273,0.273,0.275,0.274,0.276,0.275,0.276,0.276,0.279,0.276,0.275,0.281,0.28,0.285,0.284,0.282,0.282,0.286,0.285,0.282,0.288,0.285,0.284,0.288,0.286,0.287,0.291,0.284,0.287,0.292,0.289,0.293,0.293,0.293,0.29,0.298,0.292,0.291,0.292,0.292,0.294,0.292,0.294,0.293,0.295,0.293,0.293,0.298,0.293,0.297,0.299,0.297,0.298,0.298,0.299,0.296,0.299,0.298,0.296,0.296,0.297,0.299,0.294,0.297,0.3,0.298,0.297,0.301,0.301,0.302,0.3,0.303,0.305,0.299,0.301,0.295,0.301,0.301,0.3,0.3,0.3,0.305,0.303,0.3,0.303,0.306,0.304,0.308,0.303,0.305,0.301,0.303,0.303,0.3,0.301,0.302,0.302,0.303,0.302,0.305,0.306,0.302,0.302,0.309,0.303,0.305,0.312,0.301,0.303,0.305,0.303,0.303,0.304,0.305,0.308,0.307,0.303,0.304,0.307,0.304,0.305,0.31,0.304,0.302,0.308,0.303,0.303,0.306,0.305,0.302,0.305,0.303,0.301,0.309,0.303,0.304,0.309,0.306,0.308,0.309,0.304,0.306,0.306,0.305,0.306,0.305,0.308,0.303,0.304,0.304,0.303,0.306,0.311,0.305,0.305,0.309,0.304,0.304,0.308,0.304,0.304,0.307,0.305,0.304,0.305,0.306,0.303,0.309,0.305,0.305,0.306,0.306,0.303,0.307,0.305,0.301,0.308,0.305,0.302,0.304,0.304,0.302,0.303,0.304,0.302,0.3,0.302,0.305,0.3,0.3,0.303,0.303,0.302,0.301,0.303,0.304,0.303,0.303,0.3,0.303,0.303)
spectra$bg.y2 <- # Abs <== @*: = F:calculate_expr("y[1177]")
   c(0.03,0.031,0.03,0.03,0.03,0.031,0.029,0.029,0.031,0.032,0.032,0.032,0.033,0.033,0.035,0.036,0.041,0.042,0.042,0.046,0.048,0.047,0.051,0.05,0.052,0.053,0.054,0.055,0.056,0.056,0.057,0.06,0.059,0.063,0.063,0.063,0.065,0.067,0.067,0.068,0.071,0.073,0.074,0.077,0.078,0.077,0.079,0.08,0.081,0.082,0.085,0.086,0.087,0.087,0.09,0.088,0.09,0.092,0.093,0.093,0.091,0.095,0.098,0.097,0.098,0.098,0.101,0.099,0.102,0.101,0.102,0.104,0.105,0.108,0.105,0.108,0.109,0.109,0.112,0.111,0.109,0.116,0.112,0.117,0.116,0.116,0.117,0.116,0.118,0.121,0.12,0.12,0.123,0.123,0.122,0.124,0.123,0.123,0.125,0.125,0.126,0.127,0.128,0.13,0.13,0.125,0.129,0.13,0.13,0.13,0.132,0.13,0.131,0.134,0.132,0.13,0.136,0.134,0.133,0.134,0.135,0.135,0.135,0.136,0.136,0.136,0.136,0.14,0.137,0.139,0.14,0.139,0.139,0.14,0.14,0.139,0.139,0.139,0.139,0.14,0.142,0.14,0.141,0.143,0.145,0.145,0.143,0.144,0.142,0.145,0.144,0.142,0.147,0.143,0.144,0.147,0.147,0.147,0.149,0.145,0.146,0.15,0.147,0.147,0.151,0.146,0.148,0.15,0.147,0.148,0.146,0.148,0.15,0.148,0.15,0.145,0.151,0.147,0.148,0.151,0.148,0.15,0.152,0.148,0.15,0.149,0.151,0.15,0.152,0.15,0.149,0.15,0.15,0.151,0.149,0.149,0.151,0.152,0.15,0.154,0.152,0.153,0.153,0.151,0.153,0.151,0.151,0.152,0.152,0.151,0.152,0.15,0.15,0.152,0.152,0.151,0.151,0.151,0.154,0.153,0.152,0.153,0.152,0.15,0.15,0.151,0.15,0.15,0.149,0.152,0.152,0.152,0.153,0.153,0.149,0.153,0.152,0.152,0.154,0.151,0.152,0.152,0.153,0.153,0.153,0.152,0.155,0.152,0.152,0.15,0.153,0.153,0.151,0.154,0.152,0.152,0.154,0.15,0.154,0.152,0.151,0.152,0.152,0.152,0.153,0.153,0.151,0.151,0.152,0.154,0.153,0.154,0.149,0.152,0.149,0.151,0.152,0.151,0.153,0.153,0.151,0.152,0.152,0.151,0.151,0.151,0.153,0.15,0.151,0.15,0.153,0.153,0.15,0.152,0.149,0.149,0.152,0.153,0.15,0.15,0.151,0.15,0.153,0.152,0.151,0.152,0.152,0.15,0.151,0.149,0.149,0.15,0.151,0.15,0.15,0.15,0.148,0.15,0.15,0.15,0.149,0.151,0.152,0.15,0.15,0.15,0.148,0.151,0.149,0.147,0.147,0.148,0.15)
spectra$bg.y3 <- # Abs <== @*: = F:calculate_expr("y[1327]")
   c(0.027,0.03,0.028,0.029,0.031,0.027,0.031,0.03,0.029,0.031,0.03,0.031,0.034,0.03,0.033,0.036,0.037,0.041,0.04,0.043,0.043,0.043,0.046,0.046,0.047,0.048,0.049,0.051,0.051,0.053,0.052,0.055,0.055,0.057,0.056,0.06,0.061,0.059,0.063,0.062,0.065,0.067,0.067,0.071,0.072,0.074,0.073,0.073,0.073,0.074,0.08,0.078,0.078,0.08,0.08,0.081,0.081,0.087,0.084,0.084,0.086,0.086,0.088,0.091,0.09,0.089,0.09,0.09,0.092,0.092,0.094,0.093,0.095,0.098,0.094,0.1,0.101,0.098,0.102,0.098,0.098,0.104,0.099,0.103,0.103,0.106,0.106,0.104,0.105,0.109,0.105,0.106,0.108,0.111,0.11,0.113,0.108,0.11,0.111,0.115,0.115,0.112,0.116,0.117,0.117,0.116,0.114,0.116,0.113,0.115,0.117,0.118,0.119,0.119,0.119,0.121,0.122,0.122,0.117,0.118,0.119,0.12,0.119,0.121,0.123,0.124,0.124,0.125,0.125,0.127,0.125,0.126,0.126,0.125,0.126,0.121,0.124,0.127,0.124,0.124,0.126,0.126,0.125,0.128,0.127,0.126,0.128,0.128,0.127,0.126,0.129,0.126,0.129,0.128,0.13,0.128,0.13,0.129,0.132,0.129,0.129,0.131,0.131,0.132,0.131,0.131,0.133,0.134,0.131,0.13,0.131,0.13,0.135,0.131,0.13,0.135,0.134,0.134,0.129,0.132,0.131,0.132,0.136,0.135,0.131,0.129,0.133,0.132,0.133,0.132,0.131,0.133,0.134,0.133,0.132,0.13,0.135,0.135,0.131,0.132,0.133,0.135,0.134,0.136,0.137,0.132,0.136,0.132,0.136,0.134,0.134,0.133,0.131,0.133,0.133,0.132,0.134,0.138,0.135,0.134,0.135,0.134,0.135,0.132,0.133,0.134,0.134,0.133,0.132,0.136,0.134,0.136,0.135,0.131,0.132,0.138,0.134,0.131,0.136,0.135,0.137,0.134,0.132,0.134,0.134,0.135,0.132,0.136,0.137,0.137,0.132,0.132,0.136,0.136,0.135,0.138,0.135,0.136,0.135,0.137,0.134,0.132,0.133,0.131,0.131,0.135,0.132,0.133,0.132,0.136,0.135,0.135,0.134,0.133,0.133,0.131,0.135,0.133,0.134,0.133,0.132,0.134,0.131,0.133,0.136,0.133,0.132,0.135,0.135,0.134,0.135,0.133,0.133,0.135,0.133,0.133,0.132,0.133,0.137,0.134,0.134,0.134,0.134,0.133,0.135,0.135,0.132,0.134,0.131,0.132,0.133,0.13,0.133,0.13,0.132,0.133,0.132,0.131,0.133,0.131,0.131,0.131,0.133,0.129,0.132,0.133,0.133,0.13,0.13,0.129,0.131,0.13,0.133)
# now generate the fityk background string
spectra$fit.bg <-
   paste0("%bg", spectra$number, " = Spline(",
          spectra$bg.x1, ",",
          spectra$bg.y1, ", ",
          spectra$bg.x2, ",",
          spectra$bg.y2, ", ",
          spectra$bg.x3, ",",
          spectra$bg.y3, ")")
# use it like this: cat(spectra$fit.bg, sep="\n")
# now the fityk string to actually apply each bg
spectra$remove.bg <-
   paste0("@", spectra$number, ": ",
          "Y = y - %bg", spectra$number, "(x)")
# use it like this: cat(spectra$remove.bg, sep="\n")
# now place the initial kernels (the same for all spectra)
spectra$create.kernels <-
   paste0("@*: ",
          "F += Gaussian(height=~0.50, center=~666, hwhm=~16)", "; ",
          "F += Gaussian(height=~0.25, center=~628, hwhm=~32)")
# use it like this: cat(unique(spectra$create.kernels))
# and now we fit, all spectra in one go (this might take a few minutes, depending on CPU and # spectra)
spectra$fit <- "@*: fit"
# For each dataset write output of the info peaks command to a file named after the data file
# @*: lua F:execute("info peaks > '%s.peaks'" % F:get_info("filename")) # drawback: .txt.peaks extension
spectra$print.peaks <-
   paste0("@", spectra$number, ": ",
          "info peaks > '", sub("\\.txt$", ".peaks", spectra$files), "'")
# use it like this: cat(spectra$print.peaks, sep = "\n")
# For each dataset write output of the info confidence command to a file named after the data file
# @*: lua F:execute("info confidence 95 > '%s.errors'" % F:get_info("filename"))
spectra$print.errors <-
   paste0("@", spectra$number, ": ",
          "info confidence 95 > '", sub("\\.txt$", ".errors", spectra$files), "'")
# use it like this: cat(spectra$print.errors, sep = "\n")
# print the full dataset (with obs, function, bg and so on) in case you want to recreate the plots
spectra$print.data <-
   paste0("@", spectra$number, ": ",
          "print if a: x, y, a, F(x), y-F(x) > '",
          sub("\\.txt$", ".dat", spectra$files), "'")
# use it like this: cat(spectra$print.data, sep = "\n")
# Finally, you may want to save the complete Fityk session state (very large ASCII file)
spectra$save.session <-
   paste0(
      "info state > '",
      here::here("assets/data/P12/PC/session-N02A-small.fit"),
      "'")
@


<<'0512P-MB-N02A-small-nostir-fityk-errors', warning=FALSE>>=
if (!file.exists(here::here("assets/data/P12/PC/MB-N02A-small-fityk-errors.rda.gz"))) {
   fityk.files <-
      list.files(
         path = here::here("assets/data/P12/PC/160424-N02A"),
         pattern = "*.errors",
         full.names = TRUE)
   fityk.errors.small.N02A.nostir.MB.max <- NULL
   for (i in 1:length(fityk.files)) {
      this.df <-
         read.table(fityk.files[i], skip = 1, sep = "=") %>%
         # drop the redundant first column
         select(-V1) %>%
         # replace the "+-" separator with a single character so we can use separate()
         mutate(V2 = sub(" +- ", ",", V2, fixed = TRUE)) %>%
         separate(V2, sep = ",", into = c("value", "error")) %>%
         # make sure value and error columns are numeric
         mutate(value = as.numeric(value)) %>%
         # this line causes multiple warnings ("NAs introduced by coercion")
         mutate(error = as.numeric(error)) %>%
         mutate(property = rep(c("height", "center", "hwhm"), 2)) %>%
         mutate(peak = c(rep(1, 3), rep(2, 3))) %>%
         mutate(spectra = basename(fityk.files[i]) %>%
                   sub(x=., "\\.errors", "") %>%
                   sub(x=., "N02A-\\d{2}", "") %>%
                   as.numeric())
      fityk.errors.small.N02A.nostir.MB.max <-
         rbind(fityk.errors.small.N02A.nostir.MB.max,
               this.df)
   }
   fityk.errors.small.N02A.nostir.MB.max <-
      fityk.errors.small.N02A.nostir.MB.max %>%
      filter(property == "height")
   # since the peak fitting as automatic, a few fits are nonsense
   # so replace any error that is larger than its value by NA
   fityk.errors.small.N02A.nostir.MB.max$error[which(fityk.errors.small.N02A.nostir.MB.max$error > fityk.errors.small.N02A.nostir.MB.max$value)] <- NA
   save(
      fityk.errors.small.N02A.nostir.MB.max,
      file = here::here("assets/data/P12/PC/MB-N02A-small-fityk-errors.rda.gz"),
      compress = "gzip")
} else {
   fityk.errors.small.N02A.nostir.MB.max <- common::LoadRData2Variable(
      path = here::here("assets/data/P12/PC/MB-N02A-small-fityk-errors.rda.gz"))
}
@


<<'0512P-MB-N02A-small-nostir-fityk-peaks', warning=FALSE>>=
if (!file.exists(here::here("assets/data/P12/PC/MB-N02A-small-fityk-peaks.rda.gz"))) {
   fityk.files <-
      list.files(
         path = here::here("assets/data/P12/PC/160424-N02A"),
         pattern = "*.peaks",
         full.names = TRUE)
   fityk.peaks.small.N02A.nostir.MB.max <- NULL
   for (i in 1:length(fityk.files)) {
      fityk.peaks.small.N02A.nostir.MB.max <-
         rbind(fityk.peaks.small.N02A.nostir.MB.max,
               cbind(spectra = as.numeric(sub("N02A-\\d{2}", "",
                                              sub("\\.peaks", "", basename(fityk.files[i])))),
                     read.table(fityk.files[i],
                                skip = 1,
                                # skip the last three columns (fityk's output is verbose)
                                colClasses = c(rep(NA, 6), rep("NULL", 3)),
                                col.names = c("peak", "type", "center", "height", "area", "fwhm",
                                              "", "", ""))))
   }
   # drop unphysical fits (or actually, keep only physically reasonable fits)
   fityk.peaks.small.N02A.nostir.MB.max <-
      fityk.peaks.small.N02A.nostir.MB.max %>%
      filter(fwhm < 90) %>%
      filter(height > -0.1) %>%
      filter(center > 600 & center < 700)
   # drop visual outliers
   fityk.peaks.small.N02A.nostir.MB.max <-
      fityk.peaks.small.N02A.nostir.MB.max[
         -which(fityk.peaks.small.N02A.nostir.MB.max$spectra > 50 &
                   fityk.peaks.small.N02A.nostir.MB.max$height > 0.3), ]
   fityk.peaks.small.N02A.nostir.MB.max$peakno <-
      as.numeric(sub("%_", "", fityk.peaks.small.N02A.nostir.MB.max$peak))
   # calculate concentration (mol/L) from fitted height
   fityk.peaks.small.N02A.nostir.MB.max$conc.MB <-
      fityk.peaks.small.N02A.nostir.MB.max$height / abs.coeff.MB.max
   # Above line throws warning messages:
   # 1: In idyid * dy :
   #   longer object length is not a multiple of shorter object length
   # 2: In idyid * dy :
   #   longer object length is not a multiple of shorter object length
   # 3: In idyid * dy :
   #   longer object length is not a multiple of shorter object length
   # 4: In idyid * dy :
   #   longer object length is not a multiple of shorter object length
   # calculate C/C0
   fityk.peaks.small.N02A.nostir.MB.max$conc.ratio <-
      fityk.peaks.small.N02A.nostir.MB.max$conc.MB / fityk.peaks.small.N02A.nostir.MB.max$conc.MB[1]
   # join height error from errors into this df
   fityk.peaks.small.N02A.nostir.MB.max <- left_join(
      fityk.peaks.small.N02A.nostir.MB.max,
      fityk.errors.small.N02A.nostir.MB.max %>% select(value, error),
      by = c("height" = "value")) %>%
      rename(height.error = error)
   # Warning message emitted by left_join:
   # Detected an unexpected many-to-many relationship between `x` and `y`.
   # ℹ Row 141 of `x` matches multiple rows in `y`.
   # ℹ Row 210 of `y` matches multiple rows in `x`.
   # ℹ If a many-to-many relationship is expected, set `relationship = "many-to-many"`
   # to silence this warning.
   # Hmm, that's a weird join operation - it seems I'm not using any identifiying column. Should probably improve that...
   # set_error in the height column itself and drop height.error column
   fityk.peaks.small.N02A.nostir.MB.max$height <-
      set_errors(fityk.peaks.small.N02A.nostir.MB.max$height,
                 fityk.peaks.small.N02A.nostir.MB.max$height.error)
   fityk.peaks.small.N02A.nostir.MB.max <-
      fityk.peaks.small.N02A.nostir.MB.max %>% select(-height.error)
   save(
      fityk.peaks.small.N02A.nostir.MB.max,
      file = here::here("assets/data/P12/PC/MB-N02A-small-fityk-peaks.rda.gz"),
      compress = "gzip")
} else {
   fityk.peaks.small.N02A.nostir.MB.max <- LoadRData2Variable(
      path = here::here("assets/data/P12/PC/MB-N02A-small-fityk-peaks.rda.gz"))
}
@








%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% medium NP (PS data)
%%% NP initial size: MEDIUM
%%% NO STIRRING

<<'0512P-read-N04H-medium-nostir'>>=
pc.abs.medium.N04H.nostir <-
   LoadRData2Variable(here::here("assets/data/P12/PC/abs-pc-spectra-N04H-medium-nostir.rda.gz")) %>%
   filter(intensity >= 0) %>%
   filter(wavelength >= 285 & wavelength <= 1050)
# add time and adjusted time to df
# time can be constructed by reading the five last digits of sampleid
# time.abs is the time (in minutes) since the first abs measurement
pc.abs.medium.N04H.nostir$time.abs <- as.numeric(gsub("^N04H-", "", pc.abs.medium.N04H.nostir$sampleid))
# time.exp is the time (in minutes) since the mixing of the precursors
pc.abs.medium.N04H.nostir$time.exp <- pc.abs.medium.N04H.nostir$time.abs + 0 # not corrected
# express wavelength as energy (convert nm to eV)
pc.abs.medium.N04H.nostir$eV <- wavelength2energy(pc.abs.medium.N04H.nostir$wavelength)
# square the measured abs (without any correction for negative values)
pc.abs.medium.N04H.nostir$sqabs <- pc.abs.medium.N04H.nostir$intensity^2
# saved spectra no. in its own column (split it off from sampleid string)
pc.abs.medium.N04H.nostir$spectra <- as.numeric(sub("^N04H-", "", pc.abs.medium.N04H.nostir$sampleid))
# add a fitted = {TRUE or FALSE} column to pc.abs.medium.N04H
pc.abs.medium.N04H.nostir$fitted <- FALSE
@


<<'0512P-NPBE-N04H-medium-nostir-photodegradation-fit-bandgap'>>=
# the band edge eventually flattens out
edge.time.cutoff <- subset(cutoffs, sample == "N04H-medium-nostir")$bandgap
# Limit data to eV range of interest
# also, ceiling should end before it intersects with the floors
E.range.floor <- c(2.8, max(pc.abs.medium.N04H.nostir$eV))
E.range.ceiling <- c(3.4, max(pc.abs.medium.N04H.nostir$eV))
# Note that E.range.floor encompasses E.range.ceiling (by design)
floor.pc.abs.medium.N04H.nostir <-
   pc.abs.medium.N04H.nostir %>%
   filter(spectra <= edge.time.cutoff) %>%
   filter(eV >= min(E.range.floor) & eV <= max(E.range.floor))
ceiling.pc.abs.medium.N04H.nostir <-
   pc.abs.medium.N04H.nostir %>%
   filter(spectra <= edge.time.cutoff) %>%
   filter(eV >= min(E.range.ceiling) & eV <= max(E.range.ceiling))
@


<<'0512P-NPBE-N04H-medium-nostir-photodegradation-energy-ceiling'>>=
# note, we only need one sampleid in ceiling (we are using the same ceiling for all spectra)
sqabs.ceiling <-
   data.frame(eV = seq(max(E.range.ceiling), min(E.range.ceiling),
                       length.out = length(subset(ceiling.pc.abs.medium.N04H.nostir,
                                                  sampleid == unique(ceiling.pc.abs.medium.N04H.nostir$sampleid)[1])$eV)))
# the two numbers below set the slope of the ceiling
sqabs.ceiling$sqabs <-
   # these two values should be adjusted if edge.time.cutoff is changed
   seq(5.2, 1.7, length.out = length(sqabs.ceiling$eV))
@


<<'0512P-NPBE-N04H-medium-nostir-photodegradation-max-sqabs-ceiling-floor', warning=FALSE>>=
# upper and lower bounds for linear fit (squared abs, intersect with abscissa determines bandgap)
bg.fit.upper <- 0.7 # 0.7 * (ceiling - floor)
bg.fit.lower <- 0.2 # 0.2 * (ceiling - floor)
# make a condensed df (one row per sampleid, ie one row per spectrum)
condensed.abs.medium.N04H.nostir <- data.frame(sampleid = unique(pc.abs.medium.N04H.nostir$sampleid))
condensed.abs.medium.N04H.nostir$spectra <- as.numeric(sub("^N04H-", "", condensed.abs.medium.N04H.nostir$sampleid))
condensed.abs.medium.N04H.nostir$time.abs <- unique(pc.abs.medium.N04H.nostir$time.abs)
condensed.abs.medium.N04H.nostir$time.exp <- unique(pc.abs.medium.N04H.nostir$time.exp)
condensed.abs.medium.N04H.nostir$sqabs.ceiling.x <- NA
condensed.abs.medium.N04H.nostir$sqabs.ceiling.y <- NA
condensed.abs.medium.N04H.nostir$sqabs.floor.x <- NA
condensed.abs.medium.N04H.nostir$sqabs.floor.y <- NA
condensed.abs.medium.N04H.nostir$interv.high.y <- NA
condensed.abs.medium.N04H.nostir$interv.low.y <- NA
# calculated optical band gap and associated parameters
condensed.abs.medium.N04H.nostir$fit.Eg <- set_errors(NA, NA)
condensed.abs.medium.N04H.nostir$fit.adj.rsq <- NA
condensed.abs.medium.N04H.nostir$fit.points <- NA
condensed.abs.medium.N04H.nostir$fit.slope <- set_errors(NA, NA)
# absorbance at MB max peak
condensed.abs.medium.N04H.nostir$abs.MB.max <- set_errors(NA, NA)
# estimate the "floor" of the bandgap by fitting a linear function to _each_ spectrum
# set the range within which each spectrum appears linear
edge.floor.fitrange <- c(min(E.range.floor), min(E.range.ceiling))
floor.pc.abs.medium.N04H.nostir$sqabs.floor <- as.numeric(NA)
# a temporary variable, for collecting sqabs.floor vectors inside the loop
floors.sqabs <- NULL
# temporary variable to hold the "fitted" TRUE/FALSE vectors
points.fitted <- NULL
#
for (s in 1:length(condensed.abs.medium.N04H.nostir$sampleid)) {
   # message("s = ", s)
   # mean abs in the bandwidth centered on the MB abs max peak
   condensed.abs.medium.N04H.nostir$abs.MB.max[s] <-
      set_errors(subset(pc.abs.medium.N04H.nostir, sampleid == unique(pc.abs.medium.N04H.nostir$sampleid)[s]) %>%
                    filter(wavelength > MB.band - 0.5 * MB.bandwidth & wavelength < MB.band + 0.5 * MB.bandwidth) %>%
                    select(intensity) %>%
                    unlist(use.names = F) %>%
                    mean(),
                 subset(pc.abs.medium.N04H.nostir, sampleid == unique(pc.abs.medium.N04H.nostir$sampleid)[s]) %>%
                    filter(wavelength > MB.band - 0.5 * MB.bandwidth & wavelength < MB.band + 0.5 * MB.bandwidth) %>%
                    select(intensity) %>%
                    unlist(use.names = F) %>%
                    sd())
   # linear fit floor
   this.floor <-
      subset(pc.abs.medium.N04H.nostir,
             sampleid == unique(pc.abs.medium.N04H.nostir$sampleid)[s])
   # message("sampleid = ", unique(pc.abs.medium.N04H.nostir$sampleid)[s])
   lm.this.floor <-
      lm(formula = sqabs ~ eV,
         data = subset(this.floor, (eV >= min(edge.floor.fitrange) & eV <= max(edge.floor.fitrange))))
   this.floor.intercept <- lm.this.floor$coefficients[1]
   this.floor.slope <- lm.this.floor$coefficients[2]
   this.floor$sqabs.floor <- this.floor.slope * this.floor$eV + this.floor.intercept
   # just book-keeping: appending to vector...
   floors.sqabs <- c(floors.sqabs, this.floor$sqabs.floor)
   # if-clause to write NA's if we are past the length of the ceiling vector
   # this is because the edge.time.cutoff setting limits the number of spectra that get ceilings
   # (all spectra at s > edge.time.cutoff + 1 should respect this setting and not have ceilings)
   if (s > edge.time.cutoff + 1) {
      condensed.abs.medium.N04H.nostir$sqabs.ceiling.y[s] <-
         condensed.abs.medium.N04H.nostir$sqabs.ceiling.x[s] <- NA
   } else {
      # find the energy value where abs reaches zero,
      # or else the energy value corresponding to minimum abs
      this.spectrum.ceiling <-
         ceiling.pc.abs.medium.N04H.nostir[which(ceiling.pc.abs.medium.N04H.nostir$sampleid ==
                                            condensed.abs.medium.N04H.nostir$sampleid[s]), ]
      # message(paste0("dim(this.spectrum.ceiling)[1] = ", dim(this.spectrum.ceiling)[1]))
      # check each point: if above the sloping maxline (green line in plot), write TRUE to "above"
      above.ceiling <- this.spectrum.ceiling$sqabs > sqabs.ceiling$sqabs
      # warn if none of the points lie above the maxline, as expected (not a given)
      if (!any(above.ceiling == TRUE)) {warning("No datapoints above ceiling for s = ", s)}
      # points always intersect when above=TRUE, then FALSE or vice versa
      # there may be more than one intersect (e.g., the spectrum can go up over the line,
      # then dip below it, and go over it again, etc.
      # Therefore, only consider the _last_ intersection point (remember, the x-scale is flipped)
      intersect.point <- which(diff(above.ceiling) != 0)[length(which(diff(above.ceiling) != 0))]
      # max sqabs:
      condensed.abs.medium.N04H.nostir$sqabs.ceiling.y[s] <- this.spectrum.ceiling$sqabs[intersect.point]
      # corresponding energy value for max sqabs:
      # (we only need this x-value for plotting the points below, and not for bandgap calc)
      condensed.abs.medium.N04H.nostir$sqabs.ceiling.x[s] <- this.spectrum.ceiling$eV[intersect.point]
   }
   ### find floor (note: this is more complicated than ceiling, because each spectrum
   ### is compared against a different floor)
   ### But we don't need to worry about edge.time.cutoff, as the floor is always defined
   this.spectrum.floor <- this.floor
   # index 1 of eV scale is the largest value in eV, index last is the smallest value
   # at which indices is the observed curve _below_ the fitted floor?
   # (ps. this is the only place where we use the linearly fitted floor)
   above.floor <- this.spectrum.floor$sqabs > this.spectrum.floor$sqabs.floor
   # the first TRUE followed by FALSE is a good approx of the intersection point
   # warn if none of the points lie above the floor, as expected (not a given)
   if (!any(above.floor == TRUE)) {warning("No datapoint above floor for s = ", s)}
   # the intersection of interest would be the right-most (first in df)
   intersect.point <- which(diff(above.floor) != 0)[1]
   condensed.abs.medium.N04H.nostir$sqabs.floor.y[s] <- this.spectrum.floor$sqabs[intersect.point]
   condensed.abs.medium.N04H.nostir$sqabs.floor.x[s] <- this.spectrum.floor$eV[intersect.point]
   # set interval higher limit based on ceiling and floor (we only need y-values for this)
   # note: result becomes NA if ceiling.y[s] is NA
   condensed.abs.medium.N04H.nostir$interv.high.y[s] <-
      bg.fit.upper * (condensed.abs.medium.N04H.nostir$sqabs.ceiling.y[s] - condensed.abs.medium.N04H.nostir$sqabs.floor.y[s])
   # set interval lower limit based on ceiling and floor (we only need y-values for this)
   # note: result becomes NA if ceiling.y[s] is NA
   condensed.abs.medium.N04H.nostir$interv.low.y[s] <-
      bg.fit.lower * (condensed.abs.medium.N04H.nostir$sqabs.ceiling.y[s] - condensed.abs.medium.N04H.nostir$sqabs.floor.y[s])
   if (s > edge.time.cutoff + 1) {
      # fill this row with NA's if we're above edge.time.cutoff
      condensed.abs.medium.N04H.nostir$fit.Eg[s] <-
         condensed.abs.medium.N04H.nostir$fit.slope[s] <-
         condensed.abs.medium.N04H.nostir$fit.adj.rsq[s] <-
         condensed.abs.medium.N04H.nostir$fit.points[s] <- NA
   } else {
      ### here we do the linear fit to the band edge for each spectrum
      # for the current spectrum, sampleid[s], change "fitted" to TRUE for points *inside* the interval
      this.spectrum.ceiling$fitted[
         which((this.spectrum.ceiling$sqabs <= condensed.abs.medium.N04H.nostir$interv.high.y[s]) &
                  (this.spectrum.ceiling$sqabs >= condensed.abs.medium.N04H.nostir$interv.low.y[s]))] <- TRUE
      # append "fitted" vector from this.spectrum with all previous ones
      points.fitted <-
         rbind(points.fitted,
               # sampleid column here not necessary, but helps with bug-fixing
               data.frame(sampleid = this.spectrum.ceiling$sampleid,
                          fitted = this.spectrum.ceiling$fitted))
      # CALCULATE LM PARAMS FOR BAND GAP LINEAR FIT FOR THIS SPECTRUM
      this.fit <-
         lm(sqabs ~ eV, data = subset(this.spectrum.ceiling, fitted == TRUE))
      # x-intercept of fitted line (aka the band gap)
      condensed.abs.medium.N04H.nostir$fit.Eg[s] <-
         set_errors(-summary(this.fit)$coef[1,1], summary(this.fit)$coef[1,2]) /
         set_errors(summary(this.fit)$coef[2,1], summary(this.fit)$coef[2,2])
      errors(condensed.abs.medium.N04H.nostir$fit.Eg[s]) <- spectrometer.resolution
      # slope of fitted line
      condensed.abs.medium.N04H.nostir$fit.slope[s] <-
         set_errors(summary(this.fit)$coef[2,1], summary(this.fit)$coef[2,2])
      # adjusted R squared of fit
      condensed.abs.medium.N04H.nostir$fit.adj.rsq[s] <- summary(this.fit)$adj.r.squared
      # number of datapoints used for linear fit
      condensed.abs.medium.N04H.nostir$fit.points[s] <- length(subset(this.spectrum.ceiling, fitted == TRUE)$eV)
   }
}
pc.abs.medium.N04H.nostir$sqabs.floor <- floors.sqabs
ceiling.pc.abs.medium.N04H.nostir$fitted <- points.fitted$fitted
# calculate concentration (mol/L) from observed Abs and absorption coefficient at MB max wavelength
condensed.abs.medium.N04H.nostir$conc.MB <-
   condensed.abs.medium.N04H.nostir$abs.MB.max / abs.coeff.MB.max
# Warning messages:
# 1: In idyid * dy :
#   longer object length is not a multiple of shorter object length
# 2: In idyid * dy :
#   longer object length is not a multiple of shorter object length
# 3: In idyid * dy :
#   longer object length is not a multiple of shorter object length
# 4: In idyid * dy :
#   longer object length is not a multiple of shorter object length
condensed.abs.medium.N04H.nostir$conc.ratio <-
   condensed.abs.medium.N04H.nostir$conc.MB / condensed.abs.medium.N04H.nostir$conc.MB[1]
# calculate NP diameter, surface area, and volume (assuming sphere)
condensed.abs.medium.N04H.nostir$fit.np.diam <-
   diameter(condensed.abs.medium.N04H.nostir$fit.Eg, sc = "ZnO",
            a = set_errors(3.940, 0.05 * 3.940),
            b = set_errors(0.293, 0.05 * 0.293),
            c = set_errors(3.30, 0))
# Warning message:
# In diameter(condensed.abs.medium.N04H.nostir$fit.Eg, sc = "ZnO",  :
#   Two (2) supplied band gap values are less than 3.3 eV
# Treating them as NAs and moving on.
condensed.abs.medium.N04H.nostir$fit.np.area <- pi * condensed.abs.medium.N04H.nostir$fit.np.diam^2
condensed.abs.medium.N04H.nostir$fit.np.vol <- (1/6) * pi * condensed.abs.medium.N04H.nostir$fit.np.diam^3
@

<<'0512P-MB-N04H-medium-nostir-fityk-script', eval=FALSE, echo=FALSE>>=
spectra <-
   data.frame(files =
      list.files(
         path = here::here("assets/data/P12/PC/PC_MB_N04H_medium_nostir_170711"),
         pattern = "\\.txt$",
         full.names = TRUE))
spectra$number <- seq(0, length(spectra$files) - 1)
spectra$fityk.read <- paste0("@+ < '", spectra$files, "'")
spectra$fityk.read[1] <- paste0("@0 < '", spectra$files[1], "'")
# use it like this: cat(spectra$fityk.read, sep="\n")
# only the methylene blue absorption band should be "active", inactivate the rest
spectra$fityk.inactivate <-
   paste0("@*: A = a and not (801.4 < x and x < 1126.2); A = a and not (141.6 < x and x < 500.1)")
# use it like this: cat(unique(spectra$fityk.inactivate), sep="\n")
# stripping the background takes some work, since spectra may shift up/down
# We will use a spline with 3 points at the same x-values for all spectra,
# and then find the corresponding y-values for each point for each spectrum
# And finally use those 3 x,y-coordinates to create each spline function
# x-values at indices: 678, 1177, 1327 (index in vector)
spectra$bg.x1 <- 503.53 # nm <== @*: = F:calculate_expr("x[678]")
spectra$bg.x2 <- 727.39 # nm <== @*: = F:calculate_expr("x[1177]")
spectra$bg.x3 <- 793.24 # nm <== @*: = F:calculate_expr("x[1327]")
# get the y-value for each x in the same manner, except the value is not constant across spectra
spectra$bg.y1 <- # Abs <== @*: = F:calculate_expr("y[678]")
   c(0.041,0.043,0.045,0.042,0.044,0.043,0.046,0.045,0.046,0.045,0.045,0.048,0.047,0.051,0.05,0.051,0.051,0.053,0.062,0.069,0.076,0.075,0.079,0.079,0.079,0.079,0.076,0.097,0.104,0.117,0.086,0.085,0.096,0.098,0.1,0.103,0.105,0.101,0.103,0.099,0.098,0.095,0.093,0.098,0.091,0.095,0.09,0.084,0.074,0.065,0.058,0.06,0.054,0.052,0.051,0.052,0.053,0.052,0.052,0.055,0.054,0.054,0.058,0.059,0.058,0.058,0.057,0.062,0.059,0.06,0.061,0.061,0.061,0.062,0.062,0.062,0.065,0.064,0.063,0.065,0.065,0.066,0.068,0.067,0.068,0.069,0.07,0.071,0.072,0.072,0.072,0.074,0.073,0.075,0.079,0.078,0.078,0.081,0.084,0.084,0.088,0.089,0.09,0.094,0.097,0.099,0.098,0.1,0.099,0.099,0.102,0.102,0.103,0.103,0.103,0.103,0.104,0.103,0.105,0.108,0.105,0.106,0.107,0.107,0.109,0.109,0.107,0.107,0.109,0.111,0.109,0.109,0.108,0.109,0.11,0.111,0.11,0.11,0.11,0.11,0.112,0.112,0.113,0.11,0.11,0.114,0.112,0.112,0.112,0.111,0.111,0.11,0.112,0.111,0.112,0.112,0.113,0.112,0.113,0.114,0.113,0.111,0.11,0.113,0.112,0.114,0.113,0.112,0.113,0.113,0.113,0.114,0.113,0.112,0.112,0.113,0.11,0.111,0.112,0.111,0.112,0.11,0.111,0.111,0.11,0.112)
spectra$bg.y2 <- # Abs <== @*: = F:calculate_expr("y[1177]")
   c(0.024,0.025,0.024,0.025,0.024,0.023,0.025,0.025,0.025,0.027,0.025,0.026,0.027,0.029,0.028,0.029,0.03,0.034,0.035,0.039,0.043,0.043,0.044,0.045,0.044,0.047,0.044,0.051,0.058,0.063,0.048,0.049,0.05,0.054,0.056,0.057,0.054,0.053,0.054,0.051,0.051,0.05,0.05,0.051,0.05,0.048,0.05,0.047,0.04,0.037,0.032,0.032,0.029,0.031,0.028,0.029,0.027,0.029,0.028,0.03,0.029,0.029,0.031,0.034,0.032,0.031,0.031,0.032,0.033,0.034,0.033,0.034,0.034,0.032,0.033,0.035,0.034,0.034,0.034,0.035,0.037,0.036,0.038,0.038,0.039,0.039,0.038,0.041,0.04,0.042,0.043,0.041,0.044,0.043,0.043,0.044,0.045,0.047,0.048,0.052,0.052,0.053,0.055,0.057,0.059,0.061,0.059,0.063,0.061,0.063,0.065,0.065,0.065,0.063,0.067,0.068,0.067,0.069,0.069,0.069,0.07,0.072,0.071,0.071,0.073,0.072,0.07,0.074,0.074,0.074,0.073,0.074,0.075,0.072,0.074,0.076,0.074,0.075,0.077,0.076,0.074,0.076,0.077,0.075,0.077,0.077,0.075,0.077,0.078,0.078,0.079,0.077,0.077,0.078,0.079,0.08,0.079,0.078,0.077,0.08,0.08,0.079,0.079,0.081,0.081,0.078,0.08,0.079,0.081,0.081,0.08,0.081,0.081,0.081,0.08,0.08,0.081,0.08,0.08,0.079,0.082,0.082,0.078,0.08,0.08,0.079)
spectra$bg.y3 <- # Abs <== @*: = F:calculate_expr("y[1327]")
   c(0.026,0.027,0.028,0.025,0.028,0.026,0.024,0.026,0.025,0.026,0.025,0.025,0.027,0.028,0.026,0.029,0.031,0.031,0.038,0.039,0.039,0.037,0.043,0.046,0.042,0.043,0.042,0.05,0.053,0.06,0.048,0.049,0.047,0.053,0.052,0.053,0.05,0.049,0.052,0.05,0.05,0.046,0.047,0.051,0.049,0.049,0.049,0.044,0.039,0.037,0.034,0.033,0.03,0.03,0.03,0.026,0.028,0.03,0.031,0.028,0.031,0.033,0.033,0.034,0.033,0.031,0.031,0.036,0.032,0.035,0.032,0.033,0.032,0.035,0.034,0.034,0.038,0.035,0.037,0.037,0.036,0.039,0.035,0.038,0.037,0.039,0.039,0.039,0.041,0.039,0.041,0.04,0.042,0.042,0.043,0.045,0.047,0.047,0.048,0.051,0.055,0.053,0.053,0.055,0.058,0.06,0.061,0.062,0.063,0.06,0.066,0.067,0.065,0.066,0.066,0.067,0.068,0.067,0.066,0.067,0.067,0.067,0.068,0.07,0.071,0.07,0.066,0.072,0.07,0.072,0.071,0.072,0.071,0.071,0.069,0.072,0.075,0.074,0.072,0.075,0.072,0.074,0.075,0.07,0.074,0.075,0.074,0.073,0.077,0.075,0.073,0.072,0.076,0.077,0.077,0.079,0.079,0.076,0.078,0.079,0.076,0.078,0.079,0.078,0.078,0.077,0.079,0.077,0.077,0.081,0.078,0.081,0.078,0.078,0.079,0.08,0.078,0.078,0.08,0.078,0.078,0.08,0.078,0.08,0.076,0.076)
# now generate the fityk background string
spectra$fit.bg <-
   paste0("%bg", spectra$number, " = Spline(",
          spectra$bg.x1, ",",
          spectra$bg.y1, ", ",
          spectra$bg.x2, ",",
          spectra$bg.y2, ", ",
          spectra$bg.x3, ",",
          spectra$bg.y3, ")")
# use it like this: cat(spectra$fit.bg, sep="\n")
# now the fityk string to actually apply each bg
spectra$remove.bg <-
   paste0("@", spectra$number, ": ",
          "Y = y - %bg", spectra$number, "(x)")
# use it like this: cat(spectra$remove.bg, sep="\n")
# now place the initial kernels (the same for all spectra)
spectra$create.kernels <-
   paste0("@*: ",
          "F += Gaussian(height=~0.50, center=~666, hwhm=~16)", "; ",
          "F += Gaussian(height=~0.25, center=~628, hwhm=~32)")
# use it like this: cat(unique(spectra$create.kernels))
# and now we fit, all spectra in one go (this might take a few minutes, depending on CPU and # spectra)
spectra$fit <- "@*: fit"
# For each dataset write output of the info peaks command to a file named after the data file
# @*: lua F:execute("info peaks > '%s.peaks'" % F:get_info("filename")) # drawback: .txt.peaks extension
spectra$print.peaks <-
   paste0("@", spectra$number, ": ",
          "info peaks > '", sub("\\.txt$", ".peaks", spectra$files), "'")
# use it like this: cat(spectra$print.peaks, sep = "\n")
# For each dataset write output of the info confidence command to a file named after the data file
# @*: lua F:execute("info confidence 95 > '%s.errors'" % F:get_info("filename"))
spectra$print.errors <-
   paste0("@", spectra$number, ": ",
          "info confidence 95 > '", sub("\\.txt$", ".errors", spectra$files), "'")
# use it like this: cat(spectra$print.errors, sep = "\n")
spectra$print.data <-
   paste0("@", spectra$number, ": ",
          "print if a: x, y, a, F(x), y-F(x) > '",
          sub("\\.txt$", ".dat", spectra$files), "'")
# use it like this: cat(spectra$print.data, sep = "\n")
# Finally, you may want to save the complete Fityk session state (very large ASCII file)
spectra$save.session <-
   paste0(
      "info state > '",
      here::here("assets/data/P12/PC/session-N04H-medium.fit"),
      "'")
@


<<'0512P-MB-N04H-medium-nostir-fityk-errors'>>=
if (!file.exists(here::here("assets/data/P12/PC/MB-N04H-medium-fityk-errors.rda.gz"))) {
   fityk.files <- list.files(
      path = here::here("assets/data/P12/PC/PC_MB_N04H_medium_nostir_170711"),
      pattern = "*.errors",
      full.names = TRUE)
   fityk.errors.medium.N04H.nostir.MB.max <- NULL
   for (i in 1:length(fityk.files)) {
      this.df <-
         read.table(fityk.files[i], skip = 1, sep = "=") %>%
         # drop the redundant first column
         select(-V1) %>%
         # replace the "+-" separator with a single character so we can use separate()
         mutate(V2 = sub(" +- ", ",", V2, fixed = TRUE)) %>%
         separate(V2, sep = ",", into = c("value", "error")) %>%
         # make sure value and error columns are numeric
         mutate(value = as.numeric(value)) %>%
         mutate(error = as.numeric(error)) %>%
         mutate(property = rep(c("height", "center", "hwhm"), 2)) %>%
         mutate(peak = c(rep(1, 3), rep(2, 3))) %>%
         mutate(spectra = basename(fityk.files[i]) %>%
                   sub(x=., "\\.errors", "") %>%
                   sub(x=., "PC_MB_N04H_medium_nostir_170711_", "") %>%
                   as.numeric())
      fityk.errors.medium.N04H.nostir.MB.max <-
         rbind(fityk.errors.medium.N04H.nostir.MB.max,
               this.df)
   }
   fityk.errors.medium.N04H.nostir.MB.max <-
      fityk.errors.medium.N04H.nostir.MB.max %>%
      filter(property == "height")
   # since the peak fitting as automatic, a few fits are nonsense
   # so replace any error that is larger than its value by NA
   fityk.errors.medium.N04H.nostir.MB.max$error[which(fityk.errors.medium.N04H.nostir.MB.max$error > fityk.errors.medium.N04H.nostir.MB.max$value)] <- NA
   save(
      fityk.errors.medium.N04H.nostir.MB.max,
      file = here::here("assets/data/P12/PC/MB-N04H-medium-fityk-errors.rda.gz"),
      compress = "gzip")
} else {
   fityk.errors.medium.N04H.nostir.MB.max <- LoadRData2Variable(
      path = here::here("assets/data/P12/PC/MB-N04H-medium-fityk-errors.rda.gz"))
}
@


<<'0512P-MB-N04H-medium-nostir-fityk-peaks'>>=
if (!file.exists(here::here("assets/data/P12/PC/MB-N04H-medium-fityk-peaks.rda.gz"))) {
   # read the peak parameters for the MB main abs peak from fityk datafiles
   fityk.files <-
      list.files(path = here::here("assets/data/P12/PC/PC_MB_N04H_medium_nostir_170711"),
                 pattern = "*.peaks",
                 full.names = TRUE)
   fityk.peaks.medium.N04H.nostir.MB.max <- NULL
   for (i in 1:length(fityk.files)) {
      fityk.peaks.medium.N04H.nostir.MB.max <-
         rbind(fityk.peaks.medium.N04H.nostir.MB.max,
               cbind(spectra = as.numeric(sub("PC_MB_N04H_medium_nostir_170711_", "",
                                              sub("\\.peaks", "", basename(fityk.files[i])))),
                     read.table(fityk.files[i],
                                skip = 1,
                                # skip the last three columns (fityk's output is verbose)
                                colClasses = c(rep(NA, 6), rep("NULL", 3)),
                                col.names = c("peak", "type", "center", "height", "area", "fwhm",
                                              "", "", ""))))
   }
   fityk.peaks.medium.N04H.nostir.MB.max$peakno <-
      as.numeric(sub("%_", "", fityk.peaks.medium.N04H.nostir.MB.max$peak))
   # calculate concentration (mol/L) from fitted height
   fityk.peaks.medium.N04H.nostir.MB.max$conc.MB <-
      fityk.peaks.medium.N04H.nostir.MB.max$height / abs.coeff.MB.max
   # Warning messages:
   # 1: In idyid * dy :
   #   longer object length is not a multiple of shorter object length
   # 2: In idyid * dy :
   #   longer object length is not a multiple of shorter object length
   # 3: In idyid * dy :
   #   longer object length is not a multiple of shorter object length
   # 4: In idyid * dy :
   #   longer object length is not a multiple of shorter object length
   # calculate C/C0
   fityk.peaks.medium.N04H.nostir.MB.max$conc.ratio <-
      fityk.peaks.medium.N04H.nostir.MB.max$conc.MB / fityk.peaks.medium.N04H.nostir.MB.max$conc.MB[1]
   # join height error from errors into this df
   fityk.peaks.medium.N04H.nostir.MB.max <-
      left_join(fityk.peaks.medium.N04H.nostir.MB.max,
                fityk.errors.medium.N04H.nostir.MB.max %>% select(value, error),
                by = c("height" = "value")) %>%
      rename(height.error = error)
   # Warning message:
   # Detected an unexpected many-to-many relationship between `x` and `y`.
   # ℹ Row 348 of `x` matches multiple rows in `y`.
   # ℹ Row 348 of `y` matches multiple rows in `x`.
   # ℹ If a many-to-many relationship is expected, set `relationship = "many-to-many"`
   # to silence this warning.
   # set_error in the height column itself and drop height.error column
   fityk.peaks.medium.N04H.nostir.MB.max$height <-
      set_errors(fityk.peaks.medium.N04H.nostir.MB.max$height,
                 fityk.peaks.medium.N04H.nostir.MB.max$height.error)
   fityk.peaks.medium.N04H.nostir.MB.max <-
      fityk.peaks.medium.N04H.nostir.MB.max %>% select(-height.error)
   save(
      fityk.peaks.medium.N04H.nostir.MB.max,
      file = here::here("assets/data/P12/PC/MB-N04H-medium-fityk-peaks.rda.gz"),
      compress = "gzip")
} else {
   fityk.peaks.medium.N04H.nostir.MB.max <- LoadRData2Variable(
      path = here::here("assets/data/P12/PC/MB-N04H-medium-fityk-peaks.rda.gz"))
}
@






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% large NP (TA data)
%%% NP initial size: LARGE
%%% NO STIRRING

<<'0512P-read-N02A-large-nostir'>>=
#### N02A # large nanoparticles (initially)
# remove the noisy ends and data points below the abscissa
pc.abs.large.N02A.nostir <-
   LoadRData2Variable(here::here("assets/data/P12/PC/abs-pc-spectra.rda.gz")) %>%
   filter(intensity >= 0) %>%
   filter(wavelength >= 285 & wavelength <= 1050)
# add time and adjusted time to df
# time can be constructed by reading the five last digits of sampleid
# time.abs is the time (in minutes) since the first abs measurement
pc.abs.large.N02A.nostir$time.abs <- as.numeric(gsub("^N02A-", "", pc.abs.large.N02A.nostir$sampleid))
# time.exp is the time (in minutes) since the mixing of the precursors
pc.abs.large.N02A.nostir$time.exp <- pc.abs.large.N02A.nostir$time.abs + 11
# express wavelength as energy (convert nm to eV)
pc.abs.large.N02A.nostir$eV <- wavelength2energy(pc.abs.large.N02A.nostir$wavelength)
# square the measured abs (without any correction for negative values)
pc.abs.large.N02A.nostir$sqabs <- pc.abs.large.N02A.nostir$intensity^2
# saved spectra no. in its own column (split it off from sampleid string)
pc.abs.large.N02A.nostir$spectra <- as.numeric(sub("^N02A-", "", pc.abs.large.N02A.nostir$sampleid))
# add a fitted = {TRUE or FALSE} column to pc.abs.large.N02A
pc.abs.large.N02A.nostir$fitted <- FALSE
@

<<'0512P-NPBE-N02A-large-nostir-photodegradation-fit-bandgap'>>=
# the band edge eventually flattens out
edge.time.cutoff <- subset(cutoffs, sample == "N02A-large-nostir")$bandgap
# Limit data to eV range of interest
# also, ceiling should end before it intersects with the floors
E.range.floor <- c(2.8, max(pc.abs.large.N02A.nostir$eV))
E.range.ceiling <- c(3.4, max(pc.abs.large.N02A.nostir$eV))
# Note that E.range.floor encompasses E.range.ceiling (by design)
floor.pc.abs.large.N02A.nostir <-
   pc.abs.large.N02A.nostir %>%
   filter(spectra <= edge.time.cutoff) %>%
   filter(eV >= min(E.range.floor) & eV <= max(E.range.floor))
ceiling.pc.abs.large.N02A.nostir <-
   pc.abs.large.N02A.nostir %>%
   filter(spectra <= edge.time.cutoff) %>%
   filter(eV >= min(E.range.ceiling) & eV <= max(E.range.ceiling))
@

<<'0512P-NPBE-N02A-large-nostir-photodegradation-energy-ceiling'>>=
# note, we only need one sampleid in ceiling (we are using the same ceiling for all spectra)
sqabs.ceiling <-
   data.frame(eV =
                 seq(max(E.range.ceiling), min(E.range.ceiling),
                     length.out = length(subset(ceiling.pc.abs.large.N02A.nostir,
                                                sampleid == unique(ceiling.pc.abs.large.N02A.nostir$sampleid)[1])$eV)))
# the two numbers below set the slope of the ceiling
sqabs.ceiling$sqabs <-
   # these two values should be adjusted if edge.time.cutoff is changed
   seq(5.2, 1.7, length.out = length(sqabs.ceiling$eV))
@

<<'0512P-NPBE-N02A-large-nostir-photodegradation-max-sqabs-ceiling-floor', warning=FALSE>>=
# upper and lower bounds for linear fit (squared abs, intersect with abscissa determines bandgap)
bg.fit.upper <- 0.7 # 0.8 * (ceiling - floor)
bg.fit.lower <- 0.2 # 0.3 * (ceiling - floor)
# make a condensed df (one row per sampleid, ie one row per spectrum)
condensed.abs.large.N02A.nostir <- data.frame(sampleid = unique(pc.abs.large.N02A.nostir$sampleid))
condensed.abs.large.N02A.nostir$spectra <- as.numeric(sub("^N02A-", "", condensed.abs.large.N02A.nostir$sampleid))
condensed.abs.large.N02A.nostir$time.abs <- unique(pc.abs.large.N02A.nostir$time.abs)
condensed.abs.large.N02A.nostir$time.exp <- unique(pc.abs.large.N02A.nostir$time.exp)
condensed.abs.large.N02A.nostir$sqabs.ceiling.x <- NA
condensed.abs.large.N02A.nostir$sqabs.ceiling.y <- NA
condensed.abs.large.N02A.nostir$sqabs.floor.x <- NA
condensed.abs.large.N02A.nostir$sqabs.floor.y <- NA
condensed.abs.large.N02A.nostir$interv.high.y <- NA
condensed.abs.large.N02A.nostir$interv.low.y <- NA
# calculated optical band gap and associated parameters
condensed.abs.large.N02A.nostir$fit.Eg <- set_errors(NA, NA)
condensed.abs.large.N02A.nostir$fit.adj.rsq <- NA
condensed.abs.large.N02A.nostir$fit.points <- NA
condensed.abs.large.N02A.nostir$fit.slope <- set_errors(NA, NA)
# absorbance at MB max peak
condensed.abs.large.N02A.nostir$abs.MB.max <- set_errors(NA, NA)
# estimate the "floor" of the bandgap by fitting a linear function to _each_ spectrum
# set the range within which each spectrum appears linear
edge.floor.fitrange <- c(min(E.range.floor), min(E.range.ceiling))
floor.pc.abs.large.N02A.nostir$sqabs.floor <- as.numeric(NA)
# a temporary variable, for collecting sqabs.floor vectors inside the loop
floors.sqabs <- NULL
# temporary variable to hold the "fitted" TRUE/FALSE vectors
points.fitted <- NULL
#
for (s in 1:length(condensed.abs.large.N02A.nostir$sampleid)) {
   # message("s = ", s)
   # mean abs in the bandwidth centered on the MB abs max peak
   condensed.abs.large.N02A.nostir$abs.MB.max[s] <-
      set_errors(subset(pc.abs.large.N02A.nostir, sampleid == unique(pc.abs.large.N02A.nostir$sampleid)[s]) %>%
                    filter(wavelength > MB.band - 0.5 * MB.bandwidth & wavelength < MB.band + 0.5 * MB.bandwidth) %>%
                    select(intensity) %>%
                    unlist(use.names = F) %>%
                    mean(),
                 subset(pc.abs.large.N02A.nostir, sampleid == unique(pc.abs.large.N02A.nostir$sampleid)[s]) %>%
                    filter(wavelength > MB.band - 0.5 * MB.bandwidth & wavelength < MB.band + 0.5 * MB.bandwidth) %>%
                    select(intensity) %>%
                    unlist(use.names = F) %>%
                    sd())
   # linear fit floor
   this.floor <-
      subset(pc.abs.large.N02A.nostir,
             sampleid == unique(pc.abs.large.N02A.nostir$sampleid)[s])
   # message("sampleid = ", unique(pc.abs.large.N02A.nostir$sampleid)[s])
   lm.this.floor <-
      lm(formula = sqabs ~ eV,
         data = subset(this.floor, (eV >= min(edge.floor.fitrange) & eV <= max(edge.floor.fitrange))))
   this.floor.intercept <- lm.this.floor$coefficients[1]
   this.floor.slope <- lm.this.floor$coefficients[2]
   this.floor$sqabs.floor <- this.floor.slope * this.floor$eV + this.floor.intercept
   # just book-keeping: appending to vector...
   floors.sqabs <- c(floors.sqabs, this.floor$sqabs.floor)
   # if-clause to write NA's if we are past the length of the ceiling vector
   # this is because the edge.time.cutoff setting limits the number of spectra that get ceilings
   # (all spectra at s > edge.time.cutoff + 1 should respect this setting and not have ceilings)
   if (s > edge.time.cutoff + 1) {
      condensed.abs.large.N02A.nostir$sqabs.ceiling.y[s] <-
         condensed.abs.large.N02A.nostir$sqabs.ceiling.x[s] <- NA
   } else {
      # find the energy value where abs reaches zero,
      # or else the energy value corresponding to minimum abs
      this.spectrum.ceiling <-
         ceiling.pc.abs.large.N02A.nostir[which(ceiling.pc.abs.large.N02A.nostir$sampleid ==
                                            condensed.abs.large.N02A.nostir$sampleid[s]), ]
      # message(paste0("dim(this.spectrum.ceiling)[1] = ", dim(this.spectrum.ceiling)[1]))
      # check each point: if above the sloping maxline (green line in plot), write TRUE to "above"
      above.ceiling <- this.spectrum.ceiling$sqabs > sqabs.ceiling$sqabs
      # warn if none of the points lie above the maxline, as expected (not a given)
      if (!any(above.ceiling == TRUE)) {warning("No datapoints above ceiling for s = ", s)}
      # points always intersect when above=TRUE, then FALSE or vice versa
      # there may be more than one intersect (e.g., the spectrum can go up over the line,
      # then dip below it, and go over it again, etc.
      # Therefore, only consider the _last_ intersection point (remember, the x-scale is flipped)
      intersect.point <- which(diff(above.ceiling) != 0)[length(which(diff(above.ceiling) != 0))]
      # max sqabs:
      condensed.abs.large.N02A.nostir$sqabs.ceiling.y[s] <- this.spectrum.ceiling$sqabs[intersect.point]
      # corresponding energy value for max sqabs:
      # (we only need this x-value for plotting the points below, and not for bandgap calc)
      condensed.abs.large.N02A.nostir$sqabs.ceiling.x[s] <- this.spectrum.ceiling$eV[intersect.point]
   }
   ### find floor (note: this is more complicated than ceiling, because each spectrum
   ### is compared against a different floor)
   ### But we don't need to worry about edge.time.cutoff, as the floor is always defined
   this.spectrum.floor <- this.floor
   # index 1 of eV scale is the largest value in eV, index last is the smallest value
   # at which indices is the observed curve _below_ the fitted floor?
   # (ps. this is the only place where we use the linearly fitted floor)
   above.floor <- this.spectrum.floor$sqabs > this.spectrum.floor$sqabs.floor
   # the first TRUE followed by FALSE is a good approx of the intersection point
   # warn if none of the points lie above the floor, as expected (not a given)
   if (!any(above.floor == TRUE)) {warning("No datapoint above floor for s = ", s)}
   # the intersection of interest would be the right-most (first in df)
   intersect.point <- which(diff(above.floor) != 0)[1]
   condensed.abs.large.N02A.nostir$sqabs.floor.y[s] <- this.spectrum.floor$sqabs[intersect.point]
   condensed.abs.large.N02A.nostir$sqabs.floor.x[s] <- this.spectrum.floor$eV[intersect.point]
   # set interval higher limit based on ceiling and floor (we only need y-values for this)
   # note: result becomes NA if ceiling.y[s] is NA
   condensed.abs.large.N02A.nostir$interv.high.y[s] <-
      bg.fit.upper * (condensed.abs.large.N02A.nostir$sqabs.ceiling.y[s] - condensed.abs.large.N02A.nostir$sqabs.floor.y[s])
   # set interval lower limit based on ceiling and floor (we only need y-values for this)
   # note: result becomes NA if ceiling.y[s] is NA
   condensed.abs.large.N02A.nostir$interv.low.y[s] <-
      bg.fit.lower * (condensed.abs.large.N02A.nostir$sqabs.ceiling.y[s] - condensed.abs.large.N02A.nostir$sqabs.floor.y[s])
   if (s > edge.time.cutoff + 1) {
      # fill this row with NA's if we're above edge.time.cutoff
      condensed.abs.large.N02A.nostir$fit.Eg[s] <-
         condensed.abs.large.N02A.nostir$fit.slope[s] <-
         condensed.abs.large.N02A.nostir$fit.adj.rsq[s] <-
         condensed.abs.large.N02A.nostir$fit.points[s] <- NA
   } else {
      ### here we do the linear fit to the band edge for each spectrum
      # for the current spectrum, sampleid[s], change "fitted" to TRUE for points *inside* the interval
      this.spectrum.ceiling$fitted[
         which((this.spectrum.ceiling$sqabs <= condensed.abs.large.N02A.nostir$interv.high.y[s]) &
                  (this.spectrum.ceiling$sqabs >= condensed.abs.large.N02A.nostir$interv.low.y[s]))] <- TRUE
      # append "fitted" vector from this.spectrum with all previous ones
      points.fitted <-
         rbind(points.fitted,
               # sampleid column here not necessary, but helps with bug-fixing
               data.frame(sampleid = this.spectrum.ceiling$sampleid,
                          fitted = this.spectrum.ceiling$fitted))
      # CALCULATE LM PARAMS FOR BAND GAP LINEAR FIT FOR THIS SPECTRUM
      this.fit <-
         lm(sqabs ~ eV, data = subset(this.spectrum.ceiling, fitted == TRUE))
      # x-intercept of fitted line (aka the band gap)
      condensed.abs.large.N02A.nostir$fit.Eg[s] <-
         set_errors(-summary(this.fit)$coef[1,1], summary(this.fit)$coef[1,2]) /
         set_errors(summary(this.fit)$coef[2,1], summary(this.fit)$coef[2,2])
      errors(condensed.abs.large.N02A.nostir$fit.Eg[s]) <- spectrometer.resolution
      # slope of fitted line
      condensed.abs.large.N02A.nostir$fit.slope[s] <-
         set_errors(summary(this.fit)$coef[2,1], summary(this.fit)$coef[2,2])
      # adjusted R squared of fit
      condensed.abs.large.N02A.nostir$fit.adj.rsq[s] <- summary(this.fit)$adj.r.squared
      # number of datapoints used for linear fit
      condensed.abs.large.N02A.nostir$fit.points[s] <- length(subset(this.spectrum.ceiling, fitted == TRUE)$eV)
   }
}
pc.abs.large.N02A.nostir$sqabs.floor <- floors.sqabs
ceiling.pc.abs.large.N02A.nostir$fitted <- points.fitted$fitted
# calculate concentration (mol/L) from observed Abs and absorption coefficient at MB max wavelength
condensed.abs.large.N02A.nostir$conc.MB <-
   condensed.abs.large.N02A.nostir$abs.MB.max / abs.coeff.MB.max
# Warning messages:
# 1: In idyid * dy :
#   longer object length is not a multiple of shorter object length
# 2: In idyid * dy :
#   longer object length is not a multiple of shorter object length
# 3: In idyid * dy :
#   longer object length is not a multiple of shorter object length
# 4: In idyid * dy :
#   longer object length is not a multiple of shorter object length
# 5: In idyid * dy :
#   longer object length is not a multiple of shorter object length
# 6: In idyid * dy :
#   longer object length is not a multiple of shorter object length
condensed.abs.large.N02A.nostir$conc.ratio <-
   condensed.abs.large.N02A.nostir$conc.MB / condensed.abs.large.N02A.nostir$conc.MB[1]
# calculate NP diameter, surface area, and volume (assuming sphere)
condensed.abs.large.N02A.nostir$fit.np.diam <-
   diameter(condensed.abs.large.N02A.nostir$fit.Eg, sc = "ZnO",
            a = set_errors(3.940, 0.05 * 3.940),
            b = set_errors(0.293, 0.05 * 0.293),
            c = set_errors(3.30, 0))
condensed.abs.large.N02A.nostir$fit.np.area <- pi * condensed.abs.large.N02A.nostir$fit.np.diam^2
condensed.abs.large.N02A.nostir$fit.np.vol <- (1/6) * pi * condensed.abs.large.N02A.nostir$fit.np.diam^3
@

<<'0512P-MB-N02A-large-nostir-fityk-script', eval=FALSE, echo=FALSE>>=
### ONLY RUN THIS BLOCK MANUALLY, WHEN NECESSARY
spectra <-
   data.frame(
      files = list.files(
         path = here::here("assets/data/P12/PC/160504-N02A-H02AD"),
         pattern = "*.txt",
         full.names = TRUE))
spectra$number <- seq(0, length(spectra$files) - 1)
spectra$fityk.read <- paste0("@+ < '", spectra$files, "'")
spectra$fityk.read[1] <- paste0("@0 < '", spectra$files[1], "'")
# use it like this: cat(spectra$fityk.read, sep="\n")
# only the methylene blue absorption band should be "active", inactivate the rest
spectra$fityk.inactivate <-
   paste0("@*: A = a and not (801.4 < x and x < 1126.2); A = a and not (141.6 < x and x < 500.1)")
# stripping the background takes some work, since spectra may shift up/down
# We will use a spline with 3 points at the same x-values for all spectra,
# and then find the corresponding y-values for each point for each spectrum
# And finally use those 3 x,y-coordinates to create each spline function
# x-values at indices: 678, 1177, 1327 (index in vector)
spectra$bg.x1 <- 503.53 # nm <== @*: = F:calculate_expr("x[678]")
spectra$bg.x2 <- 727.39 # nm <== @*: = F:calculate_expr("x[1177]")
spectra$bg.x3 <- 793.24 # nm <== @*: = F:calculate_expr("x[1327]")
# get the y-value for each x in the same manner, except the value is not constant across spectra
spectra$bg.y1 <- # Abs <== @*: = F:calculate_expr("y[678]")
   c(0.048,0.048,0.054,0.051,0.052,0.051,0.052,0.053,0.054,0.055,0.055,0.055,0.057,0.058,0.06,
     0.062,0.064,0.064,0.065,0.068,0.072,0.079,0.08,0.086,0.086,0.089,0.095,0.107,0.085,0.085,
     0.069,0.065,0.062,0.06,0.06,0.059,0.059,0.059,0.057,0.06,0.059,0.061,0.061,0.061,0.064,0.064,
     0.065,0.067,0.067,0.067,0.072,0.072,0.073,0.076,0.078,0.076,0.079,0.08,0.085,0.087,0.087,
     0.092,0.095,0.092,0.096,0.097,0.096,0.101,0.105,0.102,0.105,0.104,0.108,0.111,0.115,0.112,
     0.112,0.11,0.113,0.117,0.116,0.113,0.115,0.119,0.119,0.118,0.12,0.121,0.12,0.12,0.121,0.121,
     0.125,0.121,0.123,0.126,0.124,0.125,0.124,0.126,0.13,0.129,0.128,0.127,0.127,0.131,0.128,0.131,
     0.129,0.13,0.13,0.127,0.132,0.131,0.13,0.13,0.132,0.131,0.131,0.132,0.131,0.132,0.129,0.129,
     0.132,0.131,0.131,0.133,0.132,0.132,0.13,0.133,0.135,0.134,0.134,0.135,0.13,0.135,0.131,0.131,
     0.13,0.133,0.132,0.13,0.132,0.132,0.128,0.132,0.134,0.135,0.133,0.131,0.131,0.133,0.133,0.13,
     0.131,0.133,0.132,0.132,0.131,0.131,0.132,0.131,0.132,0.131,0.13,0.13,0.131,0.133,0.13,0.133,
     0.131,0.131,0.131,0.128,0.129,0.129,0.127,0.129,0.127,0.127,0.129,0.128,0.128,0.13,0.13,0.127,
     0.127,0.129,0.129,0.125,0.127,0.127,0.127,0.126,0.125,0.124,0.125,0.125,0.125,0.124,0.124,0.124,
     0.124,0.125,0.123,0.123,0.123,0.123,0.122,0.124,0.124,0.124,0.123,0.122,0.121,0.122,0.121,0.122,
     0.121,0.123,0.12,0.122,0.121,0.12,0.121,0.119,0.121,0.12,0.12,0.121,0.121,0.118,0.119,0.121,0.119,
     0.119,0.118,0.12,0.118,0.118,0.118,0.119,0.116,0.119,0.115,0.117,0.116,0.115,0.116,0.115,0.114,
     0.116,0.117,0.117,0.115,0.114,0.115,0.116,0.115,0.115,0.115,0.115,0.114,0.113,0.114,0.114,0.115,
     0.115,0.114,0.114,0.112,0.114,0.114,0.113,0.112,0.112,0.111,0.112,0.113,0.112,0.113,0.113,0.111,
     0.113,0.113,0.112,0.11,0.11)
spectra$bg.y2 <- # Abs <== @*: = F:calculate_expr("y[1177]")
   c(0.032,0.031,0.033,0.031,0.032,0.032,0.034,0.032,0.034,0.034,0.033,0.033,0.033,0.032,0.035,
     0.036,0.036,0.037,0.04,0.042,0.045,0.048,0.05,0.05,0.054,0.054,0.057,0.061,0.054,0.05,0.043,
     0.041,0.039,0.038,0.037,0.037,0.036,0.036,0.035,0.036,0.036,0.038,0.035,0.039,0.037,0.037,
     0.037,0.038,0.04,0.04,0.04,0.043,0.042,0.046,0.046,0.046,0.046,0.047,0.051,0.051,0.052,0.054,
     0.055,0.055,0.057,0.057,0.056,0.06,0.061,0.061,0.062,0.061,0.067,0.066,0.072,0.067,0.07,0.066,
     0.071,0.072,0.071,0.073,0.074,0.073,0.073,0.074,0.075,0.076,0.076,0.077,0.076,0.076,0.076,
     0.076,0.081,0.08,0.08,0.08,0.081,0.082,0.082,0.085,0.083,0.084,0.083,0.083,0.083,0.085,0.087,
     0.086,0.084,0.084,0.083,0.085,0.084,0.085,0.086,0.089,0.088,0.089,0.087,0.09,0.09,0.09,0.09,
     0.088,0.087,0.088,0.091,0.089,0.091,0.093,0.091,0.092,0.091,0.09,0.091,0.09,0.09,0.092,0.09,
     0.091,0.091,0.09,0.093,0.091,0.089,0.092,0.093,0.092,0.093,0.09,0.091,0.094,0.091,0.091,0.093,
     0.091,0.092,0.091,0.093,0.091,0.091,0.093,0.094,0.093,0.091,0.09,0.091,0.091,0.091,0.092,0.091,
     0.09,0.092,0.091,0.091,0.09,0.092,0.091,0.09,0.092,0.089,0.09,0.092,0.091,0.09,0.088,0.091,
     0.092,0.092,0.091,0.09,0.091,0.09,0.089,0.091,0.089,0.089,0.088,0.09,0.089,0.089,0.088,0.088,
     0.087,0.087,0.086,0.089,0.088,0.087,0.089,0.087,0.088,0.088,0.088,0.085,0.086,0.087,0.088,
     0.087,0.086,0.086,0.086,0.086,0.086,0.086,0.087,0.086,0.084,0.087,0.084,0.086,0.085,0.085,
     0.085,0.086,0.084,0.084,0.086,0.084,0.085,0.083,0.085,0.083,0.084,0.083,0.085,0.082,0.084,
     0.083,0.083,0.087,0.084,0.085,0.085,0.083,0.083,0.084,0.082,0.082,0.085,0.082,0.084,0.085,
     0.081,0.082,0.081,0.082,0.083,0.081,0.082,0.081,0.082,0.084,0.082,0.082,0.081,0.081,0.082,
     0.082,0.08,0.082,0.083,0.083,0.083,0.081,0.081,0.082,0.081)
spectra$bg.y3 <- # Abs <== @*: = F:calculate_expr("y[1327]")
   c(0.028,0.029,0.032,0.025,0.031,0.027,0.03,0.028,0.029,0.029,0.029,0.03,0.028,0.031,0.031,
     0.033,0.036,0.037,0.036,0.04,0.042,0.045,0.045,0.049,0.049,0.051,0.052,0.054,0.046,0.045,
     0.038,0.038,0.035,0.034,0.035,0.033,0.031,0.033,0.032,0.034,0.033,0.033,0.033,0.036,0.035,
     0.034,0.035,0.036,0.037,0.036,0.038,0.042,0.036,0.041,0.044,0.04,0.042,0.043,0.046,0.048,0.048,
     0.05,0.05,0.05,0.053,0.054,0.053,0.054,0.059,0.054,0.058,0.056,0.059,0.061,0.062,0.061,0.062,
     0.06,0.066,0.066,0.065,0.065,0.065,0.067,0.067,0.068,0.07,0.07,0.071,0.069,0.073,0.07,0.076,
     0.073,0.074,0.073,0.075,0.077,0.076,0.078,0.076,0.077,0.078,0.078,0.078,0.081,0.081,0.081,0.08,
     0.079,0.079,0.077,0.082,0.08,0.083,0.081,0.083,0.082,0.083,0.083,0.085,0.081,0.082,0.085,0.084,
     0.083,0.085,0.087,0.086,0.084,0.085,0.083,0.086,0.085,0.084,0.085,0.083,0.089,0.085,0.085,0.085,
     0.089,0.085,0.089,0.088,0.086,0.084,0.086,0.086,0.087,0.091,0.087,0.086,0.089,0.085,0.088,0.09,
     0.09,0.087,0.088,0.087,0.087,0.09,0.088,0.085,0.087,0.087,0.086,0.086,0.088,0.087,0.087,0.086,
     0.089,0.09,0.086,0.092,0.087,0.088,0.088,0.086,0.085,0.088,0.087,0.088,0.088,0.086,0.088,0.088,
     0.082,0.088,0.088,0.087,0.088,0.087,0.089,0.086,0.088,0.085,0.084,0.085,0.085,0.087,0.087,0.088,
     0.084,0.086,0.085,0.084,0.087,0.083,0.083,0.087,0.087,0.085,0.085,0.087,0.084,0.087,0.083,0.086,
     0.087,0.084,0.082,0.083,0.087,0.082,0.085,0.084,0.082,0.084,0.082,0.085,0.083,0.083,0.085,0.083,
     0.083,0.084,0.084,0.082,0.084,0.083,0.084,0.08,0.082,0.084,0.081,0.081,0.081,0.081,0.079,0.081,
     0.081,0.081,0.083,0.082,0.081,0.083,0.078,0.08,0.082,0.082,0.08,0.082,0.081,0.082,0.08,0.079,
     0.081,0.08,0.083,0.081,0.082,0.078,0.078,0.082,0.079,0.08,0.081,0.08,0.08,0.079,0.081,0.079,
     0.08,0.078,0.079,0.078,0.079)
# now generate the fityk background string
spectra$fit.bg <-
   paste0("%bg", spectra$number, " = Spline(",
          spectra$bg.x1, ",",
          spectra$bg.y1, ", ",
          spectra$bg.x2, ",",
          spectra$bg.y2, ", ",
          spectra$bg.x3, ",",
          spectra$bg.y3, ")")
# use it like this: cat(spectra$fit.bg, sep="\n")
# now the fityk string to actually apply each bg
spectra$remove.bg <-
   paste0("@", spectra$number, ": ",
          "Y = y - %bg", spectra$number, "(x)")
# use it like this: cat(spectra$remove.bg, sep="\n")
# now place the initial kernels (the same for all spectra)
spectra$create.kernels <-
   paste0("@*: ",
          "F += Gaussian(height=~0.50, center=~666, hwhm=~16)", "; ",
          "F += Gaussian(height=~0.25, center=~628, hwhm=~32)")
# use it like this: cat(unique(spectra$create.kernels))
# and now we fit, all spectra in one go (this might take a few minutes, depending on CPU and # spectra)
spectra$fit <- "@*: fit"
# For each dataset write output of the info peaks command to a file named after the data file
# @*: lua F:execute("info peaks > '%s.peaks'" % F:get_info("filename")) # drawback: .txt.peaks extension
spectra$print.peaks <-
   paste0("@", spectra$number, ": ",
          "info peaks > '", sub("\\.txt$", ".peaks", spectra$files), "'")
# use it like this: cat(spectra$print.peaks, sep = "\n")
# For each dataset write output of the info confidence command to a file named after the data file
# @*: lua F:execute("info confidence 95 > '%s.errors'" % F:get_info("filename"))
spectra$print.errors <-
   paste0("@", spectra$number, ": ",
          "info confidence 95 > '", sub("\\.txt$", ".errors", spectra$files), "'")
# use it like this: cat(spectra$print.errors, sep = "\n")
# print the full dataset (with obs, function, bg and so on) in case you want to recreate the plots
spectra$print.data <-
   paste0("@", spectra$number, ": ",
          "print if a: x, y, a, F(x), y-F(x) > '",
          sub("\\.txt$", ".dat", spectra$files), "'")
# use it like this: cat(spectra$print.data, sep = "\n")
# Finally, you may want to save the complete Fityk session state (very large ASCII file)
spectra$save.session <-
   paste0(
      "info state > '",
      here::here("assets/data/P12/PC/session-N02A-large.fit"),
      "'")
@


<<'0512P-MB-N02A-large-nostir-fityk-errors'>>=
if (!file.exists(here::here("assets/data/P12/PC/MB-N02A-large-fityk-errors.rda.gz"))) {
   fityk.files <-
      list.files(
         path = here::here("assets/data/P12/PC/160504-N02A-H02AD"),
         pattern = "*.errors",
         full.names = TRUE)
   fityk.errors.large.N02A.nostir.MB.max <- NULL
   for (i in 1:length(fityk.files)) {
      this.df <-
         read.table(fityk.files[i], skip = 1, sep = "=") %>%
         # drop the redundant first column
         select(-V1) %>%
         # replace the "+-" separator with a single character so we can use separate()
         mutate(V2 = sub(" +- ", ",", V2, fixed = TRUE)) %>%
         separate(V2, sep = ",", into = c("value", "error")) %>%
         # make sure value and error columns are numeric
         mutate(value = as.numeric(value)) %>%
         mutate(error = as.numeric(error)) %>%
         mutate(property = rep(c("height", "center", "hwhm"), 2)) %>%
         mutate(peak = c(rep(1, 3), rep(2, 3))) %>%
         mutate(spectra = basename(fityk.files[i]) %>%
                   sub(x=., "\\.errors", "") %>%
                   sub(x=., "N02A-", "") %>%
                   as.numeric())
      fityk.errors.large.N02A.nostir.MB.max <-
         rbind(fityk.errors.large.N02A.nostir.MB.max,
               this.df)
   }
   fityk.errors.large.N02A.nostir.MB.max <-
      fityk.errors.large.N02A.nostir.MB.max %>%
      filter(property == "height")
   # since the peak fitting as automatic, a few fits are nonsense
   # so replace any error that is larger than its value by NA
   fityk.errors.large.N02A.nostir.MB.max$error[which(fityk.errors.large.N02A.nostir.MB.max$error > fityk.errors.large.N02A.nostir.MB.max$value)] <- NA
   save(
      fityk.errors.large.N02A.nostir.MB.max,
      file = here::here("assets/data/P12/PC/MB-N02A-large-fityk-errors.rda.gz"),
      compress = "gzip")
} else {
   fityk.errors.large.N02A.nostir.MB.max <- common::LoadRData2Variable(
      path = here::here("assets/data/P12/PC/MB-N02A-large-fityk-errors.rda.gz"))
}
@


<<'0512P-MB-N02A-large-nostir-fityk-peaks', warning=FALSE>>=
if (!file.exists(here::here("assets/data/P12/PC/MB-N02A-large-fityk-peaks.rda.gz"))) {
   fityk.files <-
      list.files(
         path = here::here("assets/data/P12/PC/160504-N02A-H02AD"),
         pattern = "*.peaks",
         full.names = TRUE)
   fityk.peaks.large.N02A.nostir.MB.max <- NULL
   for (i in 1:length(fityk.files)) {
      fityk.peaks.large.N02A.nostir.MB.max <-
         rbind(fityk.peaks.large.N02A.nostir.MB.max,
               cbind(spectra = as.numeric(sub("N02A-", "",
                                              sub("\\.peaks", "", basename(fityk.files[i])))),
                     read.table(fityk.files[i],
                                skip = 1,
                                # skip the last three columns (fityk's output is verbose)
                                colClasses = c(rep(NA, 6), rep("NULL", 3)),
                                col.names = c("peak", "type", "center", "height", "area", "fwhm",
                                              "", "", ""))))
   }
   fityk.peaks.large.N02A.nostir.MB.max$peakno <-
      as.numeric(sub("%_", "", fityk.peaks.large.N02A.nostir.MB.max$peak))
   # calculate concentration (mol/L) from fitted height
   fityk.peaks.large.N02A.nostir.MB.max$conc.MB <-
      fityk.peaks.large.N02A.nostir.MB.max$height / abs.coeff.MB.max
   # Warning messages:
   # 1: In idyid * dy :
   #   longer object length is not a multiple of shorter object length
   # 2: In idyid * dy :
   #   longer object length is not a multiple of shorter object length
   # 3: In idyid * dy :
   #   longer object length is not a multiple of shorter object length
   # 4: In idyid * dy :
   #   longer object length is not a multiple of shorter object length
   # 5: In idyid * dy :
   #   longer object length is not a multiple of shorter object length
   # 6: In idyid * dy :
   #   longer object length is not a multiple of shorter object length
   # calculate C/C0
   fityk.peaks.large.N02A.nostir.MB.max$conc.ratio <-
      fityk.peaks.large.N02A.nostir.MB.max$conc.MB / fityk.peaks.large.N02A.nostir.MB.max$conc.MB[1]
   # join height error from errors into this df
   fityk.peaks.large.N02A.nostir.MB.max <-
      left_join(fityk.peaks.large.N02A.nostir.MB.max,
                fityk.errors.large.N02A.nostir.MB.max %>% select(value, error),
                by = c("height" = "value")) %>%
      rename(height.error = error)
   # Warning message:
   # Detected an unexpected many-to-many relationship between `x` and `y`.
   # ℹ Row 116 of `x` matches multiple rows in `y`.
   # ℹ Row 116 of `y` matches multiple rows in `x`.
   # ℹ If a many-to-many relationship is expected, set `relationship = "many-to-many"`
   # to silence this warning.
   # set_error in the height column itself and drop height.error column
   fityk.peaks.large.N02A.nostir.MB.max$height <-
      set_errors(fityk.peaks.large.N02A.nostir.MB.max$height,
                 fityk.peaks.large.N02A.nostir.MB.max$height.error)
   fityk.peaks.large.N02A.nostir.MB.max <-
      fityk.peaks.large.N02A.nostir.MB.max %>% select(-height.error)
   save(
      fityk.peaks.large.N02A.nostir.MB.max,
      file = here::here("assets/data/P12/PC/MB-N02A-large-fityk-peaks.rda.gz"),
      compress = "gzip")
} else {
   fityk.peaks.large.N02A.nostir.MB.max <- common::LoadRData2Variable(
      path = here::here("assets/data/P12/PC/MB-N02A-large-fityk-peaks.rda.gz"))
}
@







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% large NP (PS data)
%%% NP initial size: LARGE
%%% NO STIRRING

<<'0512P-read-N04E-large-nostir'>>=
pc.abs.large.N04E.nostir <-
   LoadRData2Variable(here::here("assets/data/P12/PC/abs-pc-spectra-N04E-large-nostir.rda.gz")) %>%
   filter(intensity >= 0) %>%
   filter(wavelength >= 285 & wavelength <= 1050)
# add time and adjusted time to df
# time can be constructed by reading the five last digits of sampleid
# time.abs is the time (in minutes) since the first abs measurement
pc.abs.large.N04E.nostir$time.abs <- as.numeric(gsub("^N04E-", "", pc.abs.large.N04E.nostir$sampleid))
# time.exp is the time (in minutes) since the mixing of the precursors
pc.abs.large.N04E.nostir$time.exp <- pc.abs.large.N04E.nostir$time.abs + 0 # not corrected
# express wavelength as energy (convert nm to eV)
pc.abs.large.N04E.nostir$eV <- wavelength2energy(pc.abs.large.N04E.nostir$wavelength)
# square the measured abs (without any correction for negative values)
pc.abs.large.N04E.nostir$sqabs <- pc.abs.large.N04E.nostir$intensity^2
# saved spectra no. in its own column (split it off from sampleid string)
pc.abs.large.N04E.nostir$spectra <- as.numeric(sub("^N04E-", "", pc.abs.large.N04E.nostir$sampleid))
# add a fitted = {TRUE or FALSE} column to pc.abs.medium.N02A
pc.abs.large.N04E.nostir$fitted <- FALSE
@

<<'0512P-NPBE-N04E-large-nostir-photodegradation-fit-bandgap'>>=
# the band edge eventually flattens out
edge.time.cutoff <- subset(cutoffs, sample == "N04E-large-nostir")$bandgap
# Limit data to eV range of interest
# also, ceiling should end before it intersects with the floors
E.range.floor <- c(2.8, max(pc.abs.large.N04E.nostir$eV))
E.range.ceiling <- c(3.4, max(pc.abs.large.N04E.nostir$eV))
# Note that E.range.floor encompasses E.range.ceiling (by design)
floor.pc.abs.large.N04E.nostir <-
   pc.abs.large.N04E.nostir %>%
   filter(spectra <= edge.time.cutoff) %>%
   filter(eV >= min(E.range.floor) & eV <= max(E.range.floor))
ceiling.pc.abs.large.N04E.nostir <-
   pc.abs.large.N04E.nostir %>%
   filter(spectra <= edge.time.cutoff) %>%
   filter(eV >= min(E.range.ceiling) & eV <= max(E.range.ceiling))
@

<<'0512P-NPBE-N04E-large-nostir-photodegradation-energy-ceiling'>>=
# note, we only need one sampleid in ceiling (we are using the same ceiling for all spectra)
sqabs.ceiling <-
   data.frame(eV =
                 seq(max(E.range.ceiling), min(E.range.ceiling),
                     length.out = length(subset(ceiling.pc.abs.large.N04E.nostir,
                                                sampleid == unique(ceiling.pc.abs.large.N04E.nostir$sampleid)[1])$eV)))
# the two numbers below set the slope of the ceiling
sqabs.ceiling$sqabs <-
   # these two values should be adjusted if edge.time.cutoff is changed
   seq(5.2, 1.7, length.out = length(sqabs.ceiling$eV))
@

<<'0512P-NPBE-N04E-large-nostir-photodegradation-max-sqabs-ceiling-floor', warning=FALSE>>=
# upper and lower bounds for linear fit (squared abs, intersect with abscissa determines bandgap)
bg.fit.upper <- 0.7 # 0.8 * (ceiling - floor)
bg.fit.lower <- 0.2 # 0.3 * (ceiling - floor)
# make a condensed df (one row per sampleid, ie one row per spectrum)
condensed.abs.large.N04E.nostir <- data.frame(sampleid = unique(pc.abs.large.N04E.nostir$sampleid))
condensed.abs.large.N04E.nostir$spectra <- as.numeric(sub("^N04E-", "", condensed.abs.large.N04E.nostir$sampleid))
condensed.abs.large.N04E.nostir$time.abs <- unique(pc.abs.large.N04E.nostir$time.abs)
condensed.abs.large.N04E.nostir$time.exp <- unique(pc.abs.large.N04E.nostir$time.exp)
condensed.abs.large.N04E.nostir$sqabs.ceiling.x <- NA
condensed.abs.large.N04E.nostir$sqabs.ceiling.y <- NA
condensed.abs.large.N04E.nostir$sqabs.floor.x <- NA
condensed.abs.large.N04E.nostir$sqabs.floor.y <- NA
condensed.abs.large.N04E.nostir$interv.high.y <- NA
condensed.abs.large.N04E.nostir$interv.low.y <- NA
# calculated optical band gap and associated parameters
condensed.abs.large.N04E.nostir$fit.Eg <- set_errors(NA, NA)
condensed.abs.large.N04E.nostir$fit.adj.rsq <- NA
condensed.abs.large.N04E.nostir$fit.points <- NA
condensed.abs.large.N04E.nostir$fit.slope <- set_errors(NA, NA)
# absorbance at MB max peak
condensed.abs.large.N04E.nostir$abs.MB.max <- set_errors(NA, NA)
# estimate the "floor" of the bandgap by fitting a linear function to _each_ spectrum
# set the range within which each spectrum appears linear
edge.floor.fitrange <- c(min(E.range.floor), min(E.range.ceiling))
floor.pc.abs.large.N04E.nostir$sqabs.floor <- as.numeric(NA)
# a temporary variable, for collecting sqabs.floor vectors inside the loop
floors.sqabs <- NULL
# temporary variable to hold the "fitted" TRUE/FALSE vectors
points.fitted <- NULL
#
for (s in 1:length(condensed.abs.large.N04E.nostir$sampleid)) {
   # message("s = ", s)
   # mean abs in the bandwidth centered on the MB abs max peak
   condensed.abs.large.N04E.nostir$abs.MB.max[s] <-
      set_errors(subset(pc.abs.large.N04E.nostir, sampleid == unique(pc.abs.large.N04E.nostir$sampleid)[s]) %>%
                    filter(wavelength > MB.band - 0.5 * MB.bandwidth & wavelength < MB.band + 0.5 * MB.bandwidth) %>%
                    select(intensity) %>%
                    unlist(use.names = F) %>%
                    mean(),
                 subset(pc.abs.large.N04E.nostir, sampleid == unique(pc.abs.large.N04E.nostir$sampleid)[s]) %>%
                    filter(wavelength > MB.band - 0.5 * MB.bandwidth & wavelength < MB.band + 0.5 * MB.bandwidth) %>%
                    select(intensity) %>%
                    unlist(use.names = F) %>%
                    sd())
   # linear fit floor
   this.floor <-
      subset(pc.abs.large.N04E.nostir,
             sampleid == unique(pc.abs.large.N04E.nostir$sampleid)[s])
   # message("sampleid = ", unique(pc.abs.large.N04E.nostir$sampleid)[s])
   lm.this.floor <-
      lm(formula = sqabs ~ eV,
         data = subset(this.floor, (eV >= min(edge.floor.fitrange) & eV <= max(edge.floor.fitrange))))
   this.floor.intercept <- lm.this.floor$coefficients[1]
   this.floor.slope <- lm.this.floor$coefficients[2]
   this.floor$sqabs.floor <- this.floor.slope * this.floor$eV + this.floor.intercept
   # just book-keeping: appending to vector...
   floors.sqabs <- c(floors.sqabs, this.floor$sqabs.floor)
   # if-clause to write NA's if we are past the length of the ceiling vector
   # this is because the edge.time.cutoff setting limits the number of spectra that get ceilings
   # (all spectra at s > edge.time.cutoff + 1 should respect this setting and not have ceilings)
   if (s > edge.time.cutoff + 1) {
      condensed.abs.large.N04E.nostir$sqabs.ceiling.y[s] <-
         condensed.abs.large.N04E.nostir$sqabs.ceiling.x[s] <- NA
   } else {
      # find the energy value where abs reaches zero,
      # or else the energy value corresponding to minimum abs
      this.spectrum.ceiling <-
         ceiling.pc.abs.large.N04E.nostir[which(ceiling.pc.abs.large.N04E.nostir$sampleid ==
                                            condensed.abs.large.N04E.nostir$sampleid[s]), ]
      # message(paste0("dim(this.spectrum.ceiling)[1] = ", dim(this.spectrum.ceiling)[1]))
      # check each point: if above the sloping maxline (green line in plot), write TRUE to "above"
      above.ceiling <- this.spectrum.ceiling$sqabs > sqabs.ceiling$sqabs
      # warn if none of the points lie above the maxline, as expected (not a given)
      if (!any(above.ceiling == TRUE)) {warning("No datapoints above ceiling for s = ", s)}
      # points always intersect when above=TRUE, then FALSE or vice versa
      # there may be more than one intersect (e.g., the spectrum can go up over the line,
      # then dip below it, and go over it again, etc.
      # Therefore, only consider the _last_ intersection point (remember, the x-scale is flipped)
      intersect.point <- which(diff(above.ceiling) != 0)[length(which(diff(above.ceiling) != 0))]
      # max sqabs:
      condensed.abs.large.N04E.nostir$sqabs.ceiling.y[s] <- this.spectrum.ceiling$sqabs[intersect.point]
      # corresponding energy value for max sqabs:
      # (we only need this x-value for plotting the points below, and not for bandgap calc)
      condensed.abs.large.N04E.nostir$sqabs.ceiling.x[s] <- this.spectrum.ceiling$eV[intersect.point]
   }
   ### find floor (note: this is more complicated than ceiling, because each spectrum
   ### is compared against a different floor)
   ### But we don't need to worry about edge.time.cutoff, as the floor is always defined
   this.spectrum.floor <- this.floor
   # index 1 of eV scale is the largest value in eV, index last is the smallest value
   # at which indices is the observed curve _below_ the fitted floor?
   # (ps. this is the only place where we use the linearly fitted floor)
   above.floor <- this.spectrum.floor$sqabs > this.spectrum.floor$sqabs.floor
   # the first TRUE followed by FALSE is a good approx of the intersection point
   # warn if none of the points lie above the floor, as expected (not a given)
   if (!any(above.floor == TRUE)) {warning("No datapoint above floor for s = ", s)}
   # the intersection of interest would be the right-most (first in df)
   intersect.point <- which(diff(above.floor) != 0)[1]
   condensed.abs.large.N04E.nostir$sqabs.floor.y[s] <- this.spectrum.floor$sqabs[intersect.point]
   condensed.abs.large.N04E.nostir$sqabs.floor.x[s] <- this.spectrum.floor$eV[intersect.point]
   # set interval higher limit based on ceiling and floor (we only need y-values for this)
   # note: result becomes NA if ceiling.y[s] is NA
   condensed.abs.large.N04E.nostir$interv.high.y[s] <-
      bg.fit.upper * (condensed.abs.large.N04E.nostir$sqabs.ceiling.y[s] - condensed.abs.large.N04E.nostir$sqabs.floor.y[s])
   # set interval lower limit based on ceiling and floor (we only need y-values for this)
   # note: result becomes NA if ceiling.y[s] is NA
   condensed.abs.large.N04E.nostir$interv.low.y[s] <-
      bg.fit.lower * (condensed.abs.large.N04E.nostir$sqabs.ceiling.y[s] - condensed.abs.large.N04E.nostir$sqabs.floor.y[s])
   if (s > edge.time.cutoff + 1) {
      # fill this row with NA's if we're above edge.time.cutoff
      condensed.abs.large.N04E.nostir$fit.Eg[s] <-
         condensed.abs.large.N04E.nostir$fit.slope[s] <-
         condensed.abs.large.N04E.nostir$fit.adj.rsq[s] <-
         condensed.abs.large.N04E.nostir$fit.points[s] <- NA
   } else {
      ### here we do the linear fit to the band edge for each spectrum
      # for the current spectrum, sampleid[s], change "fitted" to TRUE for points *inside* the interval
      this.spectrum.ceiling$fitted[
         which((this.spectrum.ceiling$sqabs <= condensed.abs.large.N04E.nostir$interv.high.y[s]) &
                  (this.spectrum.ceiling$sqabs >= condensed.abs.large.N04E.nostir$interv.low.y[s]))] <- TRUE
      # append "fitted" vector from this.spectrum with all previous ones
      points.fitted <-
         rbind(points.fitted,
               # sampleid column here not necessary, but helps with bug-fixing
               data.frame(sampleid = this.spectrum.ceiling$sampleid,
                          fitted = this.spectrum.ceiling$fitted))
      # CALCULATE LM PARAMS FOR BAND GAP LINEAR FIT FOR THIS SPECTRUM
      this.fit <-
         lm(sqabs ~ eV, data = subset(this.spectrum.ceiling, fitted == TRUE))
      # x-intercept of fitted line (aka the band gap)
      condensed.abs.large.N04E.nostir$fit.Eg[s] <-
         set_errors(-summary(this.fit)$coef[1,1], summary(this.fit)$coef[1,2]) /
         set_errors(summary(this.fit)$coef[2,1], summary(this.fit)$coef[2,2])
      errors(condensed.abs.large.N04E.nostir$fit.Eg[s]) <- spectrometer.resolution
      # slope of fitted line
      condensed.abs.large.N04E.nostir$fit.slope[s] <-
         set_errors(summary(this.fit)$coef[2,1], summary(this.fit)$coef[2,2])
      # adjusted R squared of fit
      condensed.abs.large.N04E.nostir$fit.adj.rsq[s] <- summary(this.fit)$adj.r.squared
      # number of datapoints used for linear fit
      condensed.abs.large.N04E.nostir$fit.points[s] <- length(subset(this.spectrum.ceiling, fitted == TRUE)$eV)
   }
}
pc.abs.large.N04E.nostir$sqabs.floor <- floors.sqabs
ceiling.pc.abs.large.N04E.nostir$fitted <- points.fitted$fitted
# calculate concentration (mol/L) from observed Abs and absorption coefficient at MB max wavelength
condensed.abs.large.N04E.nostir$conc.MB <-
   condensed.abs.large.N04E.nostir$abs.MB.max / abs.coeff.MB.max
# Warning messages:
# 1: In idyid * dy :
#   longer object length is not a multiple of shorter object length
# 2: In idyid * dy :
#   longer object length is not a multiple of shorter object length
# 3: In idyid * dy :
#   longer object length is not a multiple of shorter object length
# 4: In idyid * dy :
#   longer object length is not a multiple of shorter object length
# 5: In idyid * dy :
#   longer object length is not a multiple of shorter object length
# 6: In idyid * dy :
#   longer object length is not a multiple of shorter object length
# 7: In idyid * dy :
#   longer object length is not a multiple of shorter object length
# 8: In idyid * dy :
#   longer object length is not a multiple of shorter object length
condensed.abs.large.N04E.nostir$conc.ratio <-
   condensed.abs.large.N04E.nostir$conc.MB / condensed.abs.large.N04E.nostir$conc.MB[1]
# calculate NP diameter, surface area, and volume (assuming sphere)
condensed.abs.large.N04E.nostir$fit.np.diam <-
   diameter(condensed.abs.large.N04E.nostir$fit.Eg, sc = "ZnO",
            a = set_errors(3.940, 0.05 * 3.940),
            b = set_errors(0.293, 0.05 * 0.293),
            c = set_errors(3.30, 0))
condensed.abs.large.N04E.nostir$fit.np.area <- pi * condensed.abs.large.N04E.nostir$fit.np.diam^2
condensed.abs.large.N04E.nostir$fit.np.vol <- (1/6) * pi * condensed.abs.large.N04E.nostir$fit.np.diam^3
@

<<'0512P-MB-N04E-large-nostir-fityk-script', eval=FALSE, echo=FALSE>>=
spectra <-
   data.frame(
      files = list.files(
         path = here::here("assets/data/P12/PC/PC_MB_N04E_large_nostir_170711"),
         pattern = "\\.txt$",
         full.names = TRUE))
spectra$number <- seq(0, length(spectra$files) - 1)
spectra$fityk.read <- paste0("@+ < '", spectra$files, "'")
spectra$fityk.read[1] <- paste0("@0 < '", spectra$files[1], "'")
# use it like this: cat(spectra$fityk.read, sep="\n")
# only the methylene blue absorption band should be "active", inactivate the rest
spectra$fityk.inactivate <-
   paste0("@*: A = a and not (801.4 < x and x < 1126.2); A = a and not (141.6 < x and x < 500.1)")
# use it like this: cat(unique(spectra$fityk.inactivate), sep="\n")
# stripping the background takes some work, since spectra may shift up/down
# We will use a spline with 3 points at the same x-values for all spectra,
# and then find the corresponding y-values for each point for each spectrum
# And finally use those 3 x,y-coordinates to create each spline function
# x-values at indices: 678, 1177, 1327 (index in vector)
spectra$bg.x1 <- 503.53 # nm <== @*: = F:calculate_expr("x[678]")
spectra$bg.x2 <- 727.39 # nm <== @*: = F:calculate_expr("x[1177]")
spectra$bg.x3 <- 793.24 # nm <== @*: = F:calculate_expr("x[1327]")
# get the y-value for each x in the same manner, except the value is not constant across spectra
spectra$bg.y1 <- # Abs <== @*: = F:calculate_expr("y[678]")
   c(0.044,0.043,0.046,0.046,0.048,0.048,0.049,0.053,0.053,0.059,0.062,0.065,0.07,0.075,0.074,0.079,0.081,0.084,0.085,0.085,0.085,0.085,0.086,0.087,0.078,0.076,0.069,0.08,0.063,0.05,0.049,0.051,0.051,0.046,0.047,0.045,0.043,0.044,0.044,0.048,0.045,0.042,0.042,0.045,0.041,0.041,0.042,0.042,0.044,0.041,0.041,0.042,0.042,0.041,0.041,0.041,0.042,0.043,0.043,0.043,0.044,0.042,0.043,0.042,0.042,0.04,0.041,0.044,0.044,0.043,0.044,0.044,0.044,0.046,0.046,0.043,0.043,0.043,0.047,0.045,0.046,0.046,0.045,0.045,0.046,0.046,0.048,0.046,0.047,0.048,0.047,0.047,0.047,0.048,0.047,0.047,0.048,0.051,0.048,0.049,0.048,0.05,0.048,0.049,0.049,0.049,0.048,0.048,0.049,0.048,0.052,0.049,0.05,0.049,0.048,0.05,0.05,0.051,0.051,0.049,0.051,0.05,0.049,0.048,0.049,0.05,0.05,0.05,0.05,0.05,0.05,0.05,0.051,0.051,0.051,0.05,0.05,0.048,0.048,0.051,0.05,0.051,0.049,0.05,0.052,0.051,0.05,0.05,0.051,0.051,0.049,0.049,0.05,0.049,0.05,0.051,0.048,0.051,0.051,0.05)
spectra$bg.y2 <- # Abs <== @*: = F:calculate_expr("y[1177]")
   c(0.025,0.023,0.025,0.024,0.024,0.023,0.023,0.024,0.026,0.027,0.03,0.032,0.034,0.036,0.04,0.039,0.044,0.043,0.048,0.048,0.048,0.049,0.05,0.049,0.044,0.041,0.038,0.045,0.033,0.027,0.028,0.027,0.029,0.026,0.025,0.025,0.026,0.025,0.027,0.026,0.024,0.025,0.024,0.024,0.024,0.023,0.024,0.022,0.024,0.024,0.022,0.024,0.024,0.024,0.023,0.024,0.023,0.023,0.021,0.022,0.022,0.024,0.022,0.024,0.023,0.025,0.022,0.023,0.024,0.024,0.022,0.023,0.023,0.022,0.024,0.024,0.025,0.024,0.025,0.025,0.024,0.026,0.023,0.024,0.023,0.027,0.026,0.025,0.024,0.026,0.026,0.024,0.025,0.026,0.025,0.027,0.027,0.026,0.026,0.027,0.025,0.027,0.024,0.026,0.027,0.028,0.026,0.026,0.027,0.027,0.027,0.026,0.026,0.026,0.026,0.028,0.025,0.029,0.027,0.028,0.026,0.029,0.03,0.028,0.028,0.029,0.028,0.027,0.029,0.028,0.027,0.026,0.028,0.026,0.026,0.027,0.028,0.027,0.027,0.028,0.028,0.026,0.029,0.029,0.028,0.029,0.03,0.028,0.028,0.029,0.029,0.028,0.028,0.029,0.028,0.028,0.029,0.028,0.028,0.029)
spectra$bg.y3 <- # Abs <== @*: = F:calculate_expr("y[1327]")
   c(0.026,0.028,0.028,0.026,0.028,0.025,0.025,0.029,0.027,0.029,0.032,0.031,0.034,0.037,0.04,0.043,0.047,0.047,0.047,0.045,0.042,0.043,0.05,0.049,0.043,0.047,0.042,0.041,0.037,0.031,0.031,0.028,0.03,0.029,0.028,0.029,0.026,0.026,0.027,0.027,0.03,0.026,0.028,0.026,0.025,0.026,0.027,0.029,0.027,0.025,0.025,0.026,0.027,0.027,0.026,0.026,0.026,0.025,0.028,0.026,0.029,0.027,0.028,0.026,0.025,0.022,0.025,0.027,0.027,0.027,0.028,0.027,0.027,0.027,0.026,0.025,0.026,0.026,0.03,0.027,0.027,0.027,0.027,0.028,0.03,0.028,0.027,0.028,0.027,0.03,0.028,0.032,0.028,0.03,0.03,0.028,0.03,0.028,0.029,0.029,0.027,0.03,0.031,0.031,0.028,0.03,0.033,0.029,0.031,0.03,0.031,0.031,0.029,0.032,0.031,0.032,0.028,0.029,0.032,0.031,0.031,0.028,0.031,0.032,0.029,0.031,0.03,0.031,0.03,0.029,0.031,0.029,0.031,0.031,0.031,0.033,0.029,0.029,0.033,0.03,0.033,0.033,0.03,0.033,0.032,0.033,0.033,0.031,0.032,0.029,0.032,0.03,0.031,0.029,0.029,0.033,0.032,0.032,0.03,0.031)
# now generate the fityk background string
spectra$fit.bg <-
   paste0("%bg", spectra$number, " = Spline(",
          spectra$bg.x1, ",",
          spectra$bg.y1, ", ",
          spectra$bg.x2, ",",
          spectra$bg.y2, ", ",
          spectra$bg.x3, ",",
          spectra$bg.y3, ")")
# use it like this: cat(spectra$fit.bg, sep="\n")
# now the fityk string to actually apply each bg
spectra$remove.bg <-
   paste0("@", spectra$number, ": ",
          "Y = y - %bg", spectra$number, "(x)")
# use it like this: cat(spectra$remove.bg, sep="\n")
# now place the initial kernels (the same for all spectra)
spectra$create.kernels <-
   paste0("@*: ",
          "F += Gaussian(height=~0.50, center=~666, hwhm=~16)", "; ",
          "F += Gaussian(height=~0.25, center=~628, hwhm=~32)")
# use it like this: cat(unique(spectra$create.kernels))
# and now we fit, all spectra in one go (this might take a few minutes, depending on CPU and # spectra)
spectra$fit <- "@*: fit"
# For each dataset write output of the info peaks command to a file named after the data file
# @*: lua F:execute("info peaks > '%s.peaks'" % F:get_info("filename")) # drawback: .txt.peaks extension
spectra$print.peaks <-
   paste0("@", spectra$number, ": ",
          "info peaks > '", sub("\\.txt$", ".peaks", spectra$files), "'")
# use it like this: cat(spectra$print.peaks, sep = "\n")
# print the full dataset (with obs, function, bg and so on) in case you want to recreate the plots
spectra$print.data <-
   paste0("@", spectra$number, ": ",
          "print if a: x, y, a, F(x), y-F(x) > '",
          sub("\\.txt$", ".dat", spectra$files), "'")
# use it like this: cat(spectra$print.data, sep = "\n")
# For each dataset write output of the info confidence command to a file named after the data file
# @*: lua F:execute("info confidence 95 > '%s.errors'" % F:get_info("filename"))
spectra$print.errors <-
   paste0("@", spectra$number, ": ",
          "info confidence 95 > '", sub("\\.txt$", ".errors", spectra$files), "'")
# use it like this: cat(spectra$print.errors, sep = "\n")
# Finally, you may want to save the complete Fityk session state (very large ASCII file)
spectra$save.session <-
   paste0(
      "info state > '",
      here::here("assets/data/P12/PC/session-N04E-large.fit"),
      "'")
@


<<'0512P-MB-N04E-large-nostir-fityk-errors'>>=
if (!file.exists(here::here("assets/data/P12/PC/MB-N04E-large-fityk-errors.rda.gz"))) {
   fityk.files <-
      list.files(
         path = here::here("assets/data/P12/PC/PC_MB_N04E_large_nostir_170711"),
         pattern = "*.errors",
         full.names = TRUE)
   fityk.errors.large.N04E.nostir.MB.max <- NULL
   for (i in 1:length(fityk.files)) {
      this.df <-
         read.table(fityk.files[i], skip = 1, sep = "=") %>%
         # drop the redundant first column
         select(-V1) %>%
         # replace the "+-" separator with a single character so we can use separate()
         mutate(V2 = sub(" +- ", ",", V2, fixed = TRUE)) %>%
         separate(V2, sep = ",", into = c("value", "error")) %>%
         # make sure value and error columns are numeric
         mutate(value = as.numeric(value)) %>%
         mutate(error = as.numeric(error)) %>%
         mutate(property = rep(c("height", "center", "hwhm"), 2)) %>%
         mutate(peak = c(rep(1, 3), rep(2, 3))) %>%
         mutate(spectra = basename(fityk.files[i]) %>%
                   sub(x=., "\\.errors", "") %>%
                   sub(x=., "PC_MB_N04E_large_nostir_170711_", "") %>%
                   as.numeric())
      fityk.errors.large.N04E.nostir.MB.max <-
         rbind(fityk.errors.large.N04E.nostir.MB.max,
               this.df)
   }
   fityk.errors.large.N04E.nostir.MB.max <-
      fityk.errors.large.N04E.nostir.MB.max %>%
      filter(property == "height")
   # since the peak fitting as automatic, a few fits are nonsense
   # so replace any error that is larger than its value by NA
   fityk.errors.large.N04E.nostir.MB.max$error[which(fityk.errors.large.N04E.nostir.MB.max$error > fityk.errors.large.N04E.nostir.MB.max$value)] <- NA
   save(
      fityk.errors.large.N04E.nostir.MB.max,
      file = here::here("assets/data/P12/PC/MB-N04E-large-fityk-errors.rda.gz"),
      compress = "gzip")
} else {
   fityk.errors.large.N04E.nostir.MB.max <- common::LoadRData2Variable(
      path = here::here("assets/data/P12/PC/MB-N04E-large-fityk-errors.rda.gz"))
}
@


<<'0512P-MB-N04E-large-nostir-fityk-peaks', warning=FALSE>>=
if (!file.exists(here::here("assets/data/P12/PC/MB-N04E-large-fityk-peaks.rda.gz"))) {
   fityk.files <-
      list.files(
         path = here::here("assets/data/P12/PC/PC_MB_N04E_large_nostir_170711"),
         pattern = "*.peaks",
         full.names = TRUE)
   fityk.peaks.large.N04E.nostir.MB.max <- NULL
   for (i in 1:length(fityk.files)) {
      fityk.peaks.large.N04E.nostir.MB.max <-
         rbind(fityk.peaks.large.N04E.nostir.MB.max,
               cbind(spectra = as.numeric(sub("PC_MB_N04E_large_nostir_170711_", "",
                                              sub("\\.peaks", "", basename(fityk.files[i])))),
                     read.table(fityk.files[i],
                                skip = 1,
                                # skip the last three columns (fityk's output is verbose)
                                colClasses = c(rep(NA, 6), rep("NULL", 3)),
                                col.names = c("peak", "type", "center", "height", "area", "fwhm",
                                              "", "", ""))))
   }
   fityk.peaks.large.N04E.nostir.MB.max$peakno <-
      as.numeric(sub("%_", "", fityk.peaks.large.N04E.nostir.MB.max$peak))
   # calculate concentration (mol/L) from fitted height
   fityk.peaks.large.N04E.nostir.MB.max$conc.MB <-
      fityk.peaks.large.N04E.nostir.MB.max$height / abs.coeff.MB.max
   # Warning messages:
   # 1: In idyid * dy :
   #   longer object length is not a multiple of shorter object length
   # 2: In idyid * dy :
   #   longer object length is not a multiple of shorter object length
   # 3: In idyid * dy :
   #   longer object length is not a multiple of shorter object length
   # 4: In idyid * dy :
   #   longer object length is not a multiple of shorter object length
   # 5: In idyid * dy :
   #   longer object length is not a multiple of shorter object length
   # 6: In idyid * dy :
   #   longer object length is not a multiple of shorter object length
   # 7: In idyid * dy :
   #   longer object length is not a multiple of shorter object length
   # 8: In idyid * dy :
   #   longer object length is not a multiple of shorter object length
   # calculate C/C0
   fityk.peaks.large.N04E.nostir.MB.max$conc.ratio <-
      fityk.peaks.large.N04E.nostir.MB.max$conc.MB / fityk.peaks.large.N04E.nostir.MB.max$conc.MB[1]
   # join height error from errors into this df
   fityk.peaks.large.N04E.nostir.MB.max <-
      cbind(fityk.peaks.large.N04E.nostir.MB.max,
            height.error = fityk.errors.large.N04E.nostir.MB.max$error)
   # set_error in the height column itself and drop height.error column
   fityk.peaks.large.N04E.nostir.MB.max$height <-
      set_errors(fityk.peaks.large.N04E.nostir.MB.max$height,
                 fityk.peaks.large.N04E.nostir.MB.max$height.error)
   fityk.peaks.large.N04E.nostir.MB.max <-
      fityk.peaks.large.N04E.nostir.MB.max %>% select(-height.error)
   save(
      fityk.peaks.large.N04E.nostir.MB.max,
      file = here::here("assets/data/P12/PC/MB-N04E-large-fityk-peaks.rda.gz"),
      compress = "gzip")
} else {
   fityk.peaks.large.N04E.nostir.MB.max <- common::LoadRData2Variable(
      path = here::here("assets/data/P12/PC/MB-N04E-large-fityk-peaks.rda.gz"))
}

@


<<'0512P-figref-MB-N04E-large-nostir-photodegradation', eval=FALSE>>=
nth.spectra <- 1
this.data <-
   pc.abs.large.N04E.nostir %>%
   filter(time.abs %in% seq(0, length(unique(pc.abs.large.N04E.nostir$time.abs)), by = nth.spectra))
this.condensed <- condensed.abs.large.N04E.nostir
this.ceiling <- ceiling.pc.abs.large.N04E.nostir
this.fityk <- fityk.peaks.large.N04E.nostir.MB.max
# :: this plot includes every nth spectra (if n=1 all spectra are included)
p <-
   ggplot() +
   ### TAUC ANALYSIS
   ## highlight of MB abs peak
   geom_rect(aes(xmin = wavelength2energy(MB.band - 0.5 * MB.bandwidth),
                 xmax = wavelength2energy(MB.band + 0.5 * MB.bandwidth)),
             ymin = 0,
             ymax = 0.8,
             fill = "#F9BC00",
             colour = "#0B096C") +
   ## Line segments that help the reader to connect the bandgap inset
   geom_curve(aes(x = max(this.condensed$fit.Eg, na.rm=T),
                  y = 0,
                  xend = 2.9,
                  yend = 1.85),
              curvature = 0.5,
              angle = 90,
              ncp = 5,
              linetype = "dashed",
              colour = alpha("gray30", 0.6)) +
   geom_curve(aes(x = min(this.condensed$fit.Eg, na.rm=T),
                  y = 0,
                  xend = 2.9,
                  yend = 0.55),
              curvature = 0.52,
              angle = 90,
              ncp = 5,
              linetype = "dashed",
              colour = alpha("gray30", 0.6)) +
   ## Line segments that help the reader to connect the MB inset
   geom_curve(aes(x = wavelength2energy(MB.band + 0.5 * MB.bandwidth),
                  y = 0,
                  xend = 2,
                  yend = 3.68),
              curvature = -0.5,
              angle = 90,
              ncp = 5,
              linetype = "dashed",
              colour = alpha("gray30", 0.6)) +
   geom_curve(aes(x = wavelength2energy(MB.band + 0.5 * MB.bandwidth),
                  y = 0.65,
                  xend = 2,
                  yend = 6.92),
              curvature = -0.75,
              angle = 90,
              ncp = 5,
              linetype = "dashed",
              colour = alpha("gray30", 0.6)) +
   ## MAIN DATA
   geom_line(data = this.data,
             aes(x = eV,
                 y = sqabs,
                 group = sampleid,
                 colour = time.exp,
                 alpha = -time.exp)) +
   ## highlight first spectrum
   geom_line(data = this.data %>%
                filter(spectra == 0),
             aes(x = eV, # wavelength,
                 y = sqabs), # intensity),
             colour = alpha("red", 0.75)) +
   ## highlight last spectrum
   geom_line(data = this.data %>%
                filter(spectra == max(spectra)),
             aes(x = eV, # wavelength,
                 y = sqabs), #intensity),
             colour = alpha("red", 0.75)) +
   ## highlight Tauc lines intersecting with x-axis
   ## drawn *behind* the linear fits
   geom_segment(aes(x = min(this.condensed$fit.Eg, na.rm=T),
                    xend = max(this.condensed$fit.Eg, na.rm=T),
                    y = 0,
                    yend = 0),
                # make the line a little thicker
                size = 0.75,
                colour = "#4387BF") +
   ## Tauc linear fits
   geom_smooth(data = subset(this.ceiling, fitted == TRUE),
               aes(x = eV,
                   y = sqabs,
                   group = sampleid),
               method = "lm",
               se = FALSE,
               size = 0.2,
               colour = alpha("#D5B450", 0.75),
               linetype = 1,
               fullrange = TRUE) +
   ## labelled arrows showing direction of "time" for bandgaps and MB peak
   geom_segment(aes(x = 4.0, xend = 3.75,
                    y = 0.1, yend = 0.1),
                arrow = arrow(length = unit(0.015, "npc"))) +
   annotate("text", x = 4.03, y = 0.1, label = "$t$", size = 3.5) +
   geom_segment(aes(x = 1.75, xend = 1.75,
                    y = 0.48, yend = 0.18),
                arrow = arrow(length = unit(0.015, "npc"))) +
   annotate("text", x = 1.755, y = 0.60, label = "$t$", size = 3.5) +
   labs(x = "$E/\\unit{\\eV}$",
        y = "$A^2$") +
   scale_x_continuous(breaks = seq(1, 5, 0.5),
                      sec.axis =
                         sec_axis(~ 1239.842 / .,
                                  name = "$\\lambda/\\unit{\\nm}$")) +
   # Note that sqrt y-axis visually negates sqabs, while keeping the sqabs axis numbering
   scale_y_sqrt(expand = c(0, 0.05),
                breaks = seq(0, 8)) +
   coord_cartesian(xlim = c(1.5, 4.2),
                   ylim = c(0, 7.5)) +
   theme(legend.position = "none")
p.mbabs.fityk <- ggplot() +
   geom_errorbar(data = this.fityk %>%
                    filter(this.fityk$peakno %% 2 == 1),
                 colour = alpha("#0B096C", 0.2),
                 size = 0.2,
                 aes(x = spectra,
                     ymin = errors_min(height),
                     ymax = errors_max(height),
                     group = 1)) +
   # first point, highlighted
   geom_point(data = this.fityk %>%
                 filter(this.fityk$peakno %% 2 == 1) %>%
                 filter(spectra == 0),
              size = 1.1, # 1.75,
              colour = alpha("red", 0.30),
              aes(spectra,
                  height)) +
   # last point, highlighted
   geom_point(data = this.fityk %>%
                 filter(this.fityk$peakno %% 2 == 1) %>%
                 filter(spectra == max(spectra)),
              size = 1.1, # 1.75,
              colour = alpha("red", 0.30),
              aes(spectra,
                  height)) +
   geom_line(data = this.fityk %>%
                 filter(this.fityk$peakno %% 2 == 1),
              #shape = 21,
              #fill = "#F9BC00",
              colour = "#0B096C",
              size = 0.2,
              aes(spectra,
                  height,
                  group = 1)) +
   # label for LaTeX figure label
   geom_text(aes(label = "\\sffamily\\footnotesize\\bfseries (a)",
                 x = this.fityk %>% filter(this.fityk$peakno %% 2 == 1) %>% select(spectra) %>% max(na.rm=T),
                 y = this.fityk %>% filter(this.fityk$peakno %% 2 == 1) %>% select(height) %>% max(na.rm=T)),
             size = 3.8,
             hjust = 1, vjust = 1) +
   labs(x = "$t/\\unit{\\minute}$",
        y = "$A$") +
   theme(legend.position = "none",
         # make area outside panel transparent
         plot.background =
            element_rect(fill = NA,
                         colour = NA))
p.edge <- ggplot() +
   geom_errorbar(data = this.condensed,
              size = 0.2,
              colour = alpha("#4387BF", 0.2),
              aes(x = spectra,
                  ymin = errors_min(fit.Eg),
                  ymax = errors_max(fit.Eg))) +
   # highlight first point
   geom_point(data = this.condensed %>%
                 filter(spectra == 0),
              size = 1.25,
              colour = alpha("red", 0.30),
              aes(x = spectra,
                  y = fit.Eg)) +
   geom_point(data = this.condensed,
              shape = 21,
              size = 0.65,
              fill = "#D5B450",
              colour = "#4387BF",
              aes(x = spectra,
                  y = fit.Eg)) +
   # arrow pointing to scale
   geom_segment(aes(x = 11, xend = 0,
                    y = 3.399, yend = 3.399),
                colour = "#4387BF",
                size = 1,
                arrow = arrow(length = unit(0.035, "npc"))) +
   labs(x = "$t$/\\unit{\\minute}",
        y = "$E_\\text{g}$/\\unit{\\eV}") +
   coord_cartesian(ylim = c(3.375, 3.415)) +
   theme(legend.position = "none",
         # make area outside panel transparent
         plot.background =
            element_rect(fill = NA,
                         colour = NA))
p.edge.diam <- ggplot() +
   geom_errorbar(data = this.condensed %>%
                 filter(spectra <= subset(cutoffs, sample == "N04E-large-nostir")$diameter),
              size = 0.2,
              colour = alpha("#D5B450", 0.2),
              aes(x = spectra,
                  ymin = errors_min(fit.np.diam),
                  ymax = errors_max(fit.np.diam))) +
   geom_point(data = this.condensed %>%
                 filter(spectra <= subset(cutoffs, sample == "N04E-large-nostir")$diameter),
              size = 0.35,
              colour = "#D5B450",
              aes(x = spectra,
                  y = fit.np.diam)) +
   # arrow pointing to scale
   geom_segment(aes(x = 28, xend = 45,
                    y = 8.85, yend = 8.85),
                colour = "#D5B450",
                size = 1,
                arrow = arrow(length = unit(0.050, "npc"))) +
   # label for LaTeX figure label
   geom_text(aes(label = "\\sffamily\\footnotesize\\bfseries (b)",
                 x = max(this.condensed$spectra, na.rm=T),
                 y = max(this.condensed$fit.np.diam, na.rm=T)),
             size = 3.8,
             hjust = 1, vjust = 1) +
   labs(x = "$t/\\unit{\\minute}$",
        y = "$d/\\unit{\\nm}$") +
   scale_y_continuous(position = "right") +
   coord_cartesian(ylim = c(7.4, 9.3),
                   xlim = c(0, max(this.condensed$spectra))) +
   theme(legend.position = "none",
         # panel.grid.major = element_line(colour = alpha("red", 0.5)),
         # panel.grid.minor = element_line(colour = alpha("red", 0.5)),
         panel.grid = element_blank(),
         axis.title.x = element_blank(),
         axis.text.x = element_blank(),
         # make plot background transparent
         panel.background = element_rect(fill = NA, colour = NA),
         # make area outside panel transparent
         plot.background =
            element_rect(fill = NA,
                         colour = NA))
vp.p <- viewport(width = 1, height = 1, x = 0, y = 0, just = c("left", "bottom"))
vp.edge <-
   viewport(width = 0.30, height = 0.30,
            x = 0.25, y = 0.52, #0.55,
            just = c("left", "top"))
vp.edge.diam <-
   # due to different width of axis text and titles, width needs to be adjusted here
   # due to suppression of x text/title, the height needs to be decreased here
   viewport(width  = 0.292, # width = 0.282
            height = 0.230, # height = 0.232
            x = 0.314, y = 0.52,  # x = 0.306
            just = c("left", "top"))
vp.mbabs.fityk <-
   viewport(width = 0.30, height = 0.30,
            x = 0.20, y = 0.58,
            just = c("left", "bottom"))
print(p, vp = vp.p)
print(p.edge, vp = vp.edge)
print(p.edge.diam, vp = vp.edge.diam)
print(p.mbabs.fityk, vp = vp.mbabs.fityk)
@


<<'0512P-condensed-all'>>=
condensed.all <-
   rbind(cbind(init.np.diam = paste0(formatC(condensed.abs.large.N02A.nostir$fit.np.diam[1], 3), " nm"),
               approx.init.np.diam = paste0(formatC(condensed.abs.large.N02A.nostir$fit.np.diam[1], 2), " nm"),
               np.size = "large",
               stirring = "no",
               condensed.abs.large.N02A.nostir),
         cbind(init.np.diam = paste0(formatC(condensed.abs.large.N04E.nostir$fit.np.diam[1], 3), " nm"),
               approx.init.np.diam = paste0(formatC(condensed.abs.large.N04E.nostir$fit.np.diam[1], 2), " nm"),
               np.size = "large",
               stirring = "no",
               condensed.abs.large.N04E.nostir),
         cbind(init.np.diam = paste0(formatC(condensed.abs.medium.N04H.nostir$fit.np.diam[1], 3), " nm"),
               approx.init.np.diam = paste0(formatC(condensed.abs.medium.N04H.nostir$fit.np.diam[1], 2), " nm"),
               np.size = "medium",
               stirring = "no",
               # contains a few fit.Eg values less than 3.30 eV
               condensed.abs.medium.N04H.nostir),
         cbind(init.np.diam = paste0(formatC(condensed.abs.small.N02A.nostir$fit.np.diam[1], 3), " nm"),
               approx.init.np.diam = paste0(formatC(condensed.abs.small.N02A.nostir$fit.np.diam[1], 2), " nm"),
               np.size = "small",
               stirring = "no",
               condensed.abs.small.N02A.nostir),
         cbind(init.np.diam = paste0(formatC(condensed.abs.small.N04H.nostir$fit.np.diam[1], 3), " nm"),
               approx.init.np.diam = paste0(formatC(condensed.abs.small.N04H.nostir$fit.np.diam[1], 2), " nm"),
               np.size = "small",
               stirring = "no",
               condensed.abs.small.N04H.nostir))
# create a unique column (combine part of sampleid with np.size and stirring)
condensed.all$sample <-
   paste0(sub("-\\d+$", "", condensed.all$sampleid),
          "-", condensed.all$np.size,
          "-", ifelse(condensed.all$stirring == "yes", "stir", "nostir"))
# catch unphysical band gap values (< 3.30 eV; there's two of those in total)
rows.nonphysical.bandgaps <- which(condensed.all$fit.Eg < 3.30)
condensed.all$fit.Eg[rows.nonphysical.bandgaps] <- 3.30
condensed.all$fit.points[rows.nonphysical.bandgaps] <- as.integer(NA)
condensed.all$fit.slope[rows.nonphysical.bandgaps] <- as.numeric(NA)
@


<<'0512P-fityk-peaks-all', warning=FALSE>>=
# for the MB decolour we now have peak-fitted data for all the experiments
# we will rbind them all together into one dataframe, but also add descriptive
# columns to each part (that's what the cbinds are for)
# FROM NOW ON ONLY THE MAIN MB PEAK IS KEPT, the "shoulder" and its data is dropped here
# using > filter(peakno %% 2 == 1)
fityk.peaks.all <- rbind(
   cbind(
      sample = "N02A-small-nostir",
      np.size = "small",
      stirring = "no",
      init.np.diam = condensed.all %>%
         filter(sample == "N02A-small-nostir") %>%
         select(init.np.diam) %>%
         unique() %>%
         unlist(use.names = F),
      approx.init.np.diam = condensed.all %>%
         filter(sample == "N02A-small-nostir") %>%
         select(approx.init.np.diam) %>%
         unique() %>%
         unlist(use.names = F),
      left_join(
         x = fityk.peaks.small.N02A.nostir.MB.max %>%
            filter(peakno %% 2 == 1),
         y = condensed.all %>%
            filter(sample == "N02A-small-nostir") %>%
            select(spectra, fit.Eg, fit.np.diam, fit.np.area, fit.np.vol),
         by = "spectra")),
   cbind(
      sample = "N04H-small-nostir",
      np.size = "small",
      stirring = "no",
      init.np.diam = condensed.all %>%
         filter(sample == "N04H-small-nostir") %>%
         select(init.np.diam) %>%
         unique() %>%
         unlist(use.names = F),
      approx.init.np.diam = condensed.all %>%
         filter(sample == "N04H-small-nostir") %>%
         select(approx.init.np.diam) %>%
         unique() %>%
         unlist(use.names = F),
      left_join(
         x = fityk.peaks.small.N04H.nostir.MB.max %>%
            filter(peakno %% 2 == 1),
         y = condensed.all %>%
            filter(sample == "N04H-small-nostir") %>%
            select(spectra, fit.Eg, fit.np.diam, fit.np.area, fit.np.vol),
         by = "spectra")),
   cbind(
      sample = "N04H-medium-nostir",
      np.size = "medium",
      stirring = "no",
      init.np.diam = condensed.all %>%
         filter(sample == "N04H-medium-nostir") %>%
         select(init.np.diam) %>%
         unique() %>%
         unlist(use.names = F),
      approx.init.np.diam = condensed.all %>%
         filter(sample == "N04H-medium-nostir") %>%
         select(approx.init.np.diam) %>%
         unique() %>%
         unlist(use.names = F),
      left_join(
         x = fityk.peaks.medium.N04H.nostir.MB.max %>%
            filter(peakno %% 2 == 1),
         y = condensed.all %>%
            filter(sample == "N04H-medium-nostir") %>%
            select(spectra, fit.Eg, fit.np.diam, fit.np.area, fit.np.vol),
         by = "spectra")),
   cbind(
      sample = "N02A-large-nostir",
      np.size = "large",
      stirring = "no",
      init.np.diam = condensed.all %>%
         filter(sample == "N02A-large-nostir") %>%
         select(init.np.diam) %>%
         unique() %>%
         unlist(use.names = F),
      approx.init.np.diam = condensed.all %>%
         filter(sample == "N02A-large-nostir") %>%
         select(approx.init.np.diam) %>%
         unique() %>%
         unlist(use.names = F),
      left_join(
         x = fityk.peaks.large.N02A.nostir.MB.max %>%
            filter(peakno %% 2 == 1),
         y = condensed.all %>%
            filter(sample == "N02A-large-nostir") %>%
            select(spectra, fit.Eg, fit.np.diam, fit.np.area, fit.np.vol),
         by = "spectra")),
   cbind(
      sample = "N04E-large-nostir",
      np.size = "large",
      stirring = "no",
      init.np.diam = condensed.all %>%
         filter(sample == "N04E-large-nostir") %>%
         select(init.np.diam) %>%
         unique() %>%
         unlist(use.names = F),
      approx.init.np.diam = condensed.all %>%
         filter(sample == "N04E-large-nostir") %>%
         select(approx.init.np.diam) %>%
         unique() %>%
         unlist(use.names = F),
      left_join(
         x = fityk.peaks.large.N04E.nostir.MB.max %>%
            filter(peakno %% 2 == 1),
         y = condensed.all %>%
            filter(sample == "N04E-large-nostir") %>%
            select(spectra, fit.Eg, fit.np.diam, fit.np.area, fit.np.vol),
         by = "spectra")))
# natural log of conc ratio (this throws warning about "NaNs produced")
fityk.peaks.all$conc.nlog <- log(fityk.peaks.all$conc.ratio)
# convert minutes (spectra) to seconds
fityk.peaks.all$seconds <- 60 * fityk.peaks.all$spectra
@


<<'0512P-number-ZnO-nanoparticles-model'>>=
# macroscopic properties
bulk.density <- 5.606 # g cm-3
# Properties of ZnO in the reaction cuvette
rxn.conc <- (0.2 / 2.2) * 0.05 # mol per litre
rxn.amount <- rxn.conc * 2.2E-3 # mol
rxn.mass <- 81.38 * rxn.amount # gram
rxn.volume <- 1E21 * (rxn.mass / bulk.density) # nm-3 (nanometres cubed)
# calculate total area of the particle ensemble
# -- requires assumptions on ZnO density
# work backwards from the maximum ZnO mass (see above, 0.814 mg) and final NP diameter
np.final <- data.frame(diameter = max(condensed.all$fit.np.diam, na.rm = T))
np.final$area <- pi * np.final$diameter^2
np.final$volume <- (1/6) * pi * np.final$diameter^3
# this then gives us the number of particles
# based on the largest observed particle diameter (volume)
rxn.particles <- rxn.volume / np.final$volume
@


<<'0512P-apply-cutoffs'>>=
# apply cutoffs as specified in cutoffs to fityk.peaks.all and condensed.all
for (s in 1:length(cutoffs$sample)) {
   # band gaps, diameters, areas, volumes above the Eg cutoff replaced with NAs
   condensed.all[which(condensed.all$sample == cutoffs$sample[s] & condensed.all$spectra > cutoffs$diameter[s]),
                 c("fit.Eg", "fit.adj.rsq", "fit.points", "fit.slope",
                   "fit.np.diam", "fit.np.area", "fit.np.vol")] <- NA
}
@


<<'0512P-average-NP-growth'>>=
# What is the average rate of growth in diameter for the different sizes? Answered by this chunk
growthrate <-
   cbind(condensed.all %>%
            filter(spectra <= 10) %>%
            # group by sample to get an lm for each line in the plot fig:NPBE-diameter-all
            group_by(np.size, sample) %>%
            # we can't run class "errors" through linear modeling...
            do(linearmodel = lm(formula = as.numeric(fit.np.diam) ~ spectra, data = .)) %>%
            mutate(slope = summary(linearmodel)$coeff[2,1]) %>%
            mutate(slope.error = summary(linearmodel)$coeff[2,2]) %>%
            mutate(intercept = summary(linearmodel)$coeff[1,1]) %>%
            # I would like to use the error of fit.np.diam since that's larger and errors are lost in lm()
            # but it's quite hard to implement... still not done
            mutate(intercept.error = summary(linearmodel)$coeff[1,2]) %>%
            mutate(rsquared = summary(linearmodel)$adj.r.squared) %>%
            select(-linearmodel) %>%
            # important that this sort is identical to that below
            arrange(sample),
         condensed.all %>%
            # use the same cutoff as above
            filter(spectra <= 10) %>%
            group_by(sample, np.size) %>%
            # group_by(sample, np.size, stirring) %>%
            select(sample, np.size, init.np.diam) %>%
            # select(sample, np.size, stirring, init.np.diam) %>%
            unique() %>%
            # sort in the same way as above
            arrange(sample) %>%
            ungroup() %>%
            select(init.np.diam))
growthrate$slopewerror <-
   set_errors(growthrate$slope, growthrate$slope.error)
growthrate$interceptwerror <-
   set_errors(growthrate$intercept, growthrate$intercept.error)
@


<<'0512P-solar-spectrum-better-normalisation', eval=FALSE>>=
constant.ch <-
   1E9 * solarconstants$value[which(solarconstants$label == "c")] *
   solarconstants$value[which(solarconstants$label == "h")]
# EXP SOLAR SPECTRUM and AM1.5G SPECTRUM normalised with regards to radiance (area under the curve)
sun.theory <-
   photoec::ASTMG173 %>%
   select(wavelength, intensity = globaltilt)
sun.theory$energy <- wavelength2energy(sun.theory$wavelength)
sun.theory$spectrum <- "ASTMG173 1.5G"
sun.exp <- OO2df(here::here("assets/data/AM15_solar_simulator.txt"))
sun.exp$energy <- wavelength2energy(sun.exp$wavelength)
sun.exp$spectrum <- "Class A AM1.5 simulator"
# remove the baseline (due to electronic noise)
sun.exp.background <- sun.exp %>% filter(energy > 5 & energy < 6) %>% select(intensity) %>% unlist() %>% mean()
sun.exp$intensity <- sun.exp$intensity - sun.exp.background
# start by normalising the y-axes of sun theory and exp (simply by maxima)
sun.exp$intensity <- sun.exp$intensity /
   (max(sun.exp$intensity) / max(sun.theory$intensity))
# calculates radiances and cumulative photon flux for both exp and theory
# area under curve... (radiance)
sun.theory$radiance <- cumsum(c(0, trapz(sun.theory$wavelength, sun.theory$intensity)))
sun.exp$radiance <- cumsum(c(0, trapz(sun.exp$wavelength, sun.exp$intensity)))
# calculate photon flux (this is the cumulative flux)
sun.theory$cumflux <-
   cumsum(c(0, trapz(sun.theory$wavelength,
                     sun.theory$intensity * (sun.theory$wavelength / constant.ch))))
sun.exp$cumflux <-
   cumsum(c(0, trapz(sun.exp$wavelength,
                     sun.exp$intensity * (sun.exp$wavelength / constant.ch))))
# normalise the experimental solar spectrum with this factor
sun.exp$intensity <-
   sun.exp$intensity *
   (sun.theory %>%
       # limit wavelength/energy range to where both exp and theory exist (from approx 1 eV to 4.5 eV)
       filter(energy > min(sun.exp$energy) & energy < max(sun.theory$energy)) %>%
       select(radiance) %>% max() /
       sun.exp %>%
       # limit wavelength/energy range to where both exp and theory exist (from approx 1 eV to 4.5 eV)
       filter(energy > min(sun.exp$energy) & energy < max(sun.theory$energy)) %>%
       select(radiance) %>% max())
# recalculate radiance and cumflux for sun.exp
sun.exp$radiance <- cumsum(c(0, trapz(sun.exp$wavelength, sun.exp$intensity)))
sun.exp$cumflux <-
   cumsum(c(0, trapz(sun.exp$wavelength,
                     sun.exp$intensity * (sun.exp$wavelength / constant.ch))))
# string the two solarlamp dfs together into one
sun <-
   rbind(sun.theory %>% select(spectrum, wavelength, intensity, energy, radiance, cumflux),
         sun.exp %>% select(spectrum, wavelength, intensity, energy, radiance, cumflux))
@



<<'0512P-photon-flux-per-bandgap', , eval=FALSE, cache=FALSE>>=
# towards a tabular of flux for each band gap of interest
# "Availability of photon flux at different band gaps"
bandgaps <-
   left_join(x = condensed.all %>%
             group_by(sample) %>%
             # max band gap for each sample
             slice(which.max(fit.Eg)) %>%
             # rename columns...
             mutate(init.Eg = fit.Eg) %>%
             mutate(init.diam = fit.np.diam) %>%
             select(sample, init.Eg, init.diam),
          y = condensed.all %>%
             group_by(sample) %>%
             # min band gap for each sample
             slice(which.min(fit.Eg)) %>%
             # rename columns...
             mutate(last.Eg = fit.Eg) %>%
             mutate(last.diam = fit.np.diam) %>%
             select(sample, last.Eg, last.diam),
          by = "sample") %>%
   ## MEAN AND SDEV OF NUMBER OF FITTED POINTS
   left_join(., condensed.all %>%
                group_by(sample) %>%
                # average number of fitted points
                summarise(mean.points = mean(fit.points, na.rm = T)),
             by = "sample") %>%
   left_join(., condensed.all %>%
                group_by(sample) %>%
                # standard dev of fitted points
                summarise(sd.points = sd(fit.points, na.rm = T)),
             by = "sample") %>%
   ## MEAN AND SDEV OF R-SQUARED
   left_join(., condensed.all %>%
                group_by(sample) %>%
                # average R^2
                summarise(mean.rsquare = mean(fit.adj.rsq, na.rm = T)),
             by = "sample") %>%
   left_join(., condensed.all %>%
                group_by(sample) %>%
                # standard dev of R^2
                summarise(sd.rsquare = sd(fit.adj.rsq, na.rm = T)),
             by = "sample")
# calculate flux
bandgaps$init.cumflux <- cumflux(energy2wavelength(bandgaps$init.Eg))
bandgaps$last.cumflux <- cumflux(energy2wavelength(bandgaps$last.Eg))
# fraction of flux of total AM1.5G flux
bandgaps$init.cumflux.percent <- 100 * (bandgaps$init.cumflux / tail(sun.theory$cumflux, 1))
bandgaps$last.cumflux.percent <- 100 * (bandgaps$last.cumflux / tail(sun.theory$cumflux, 1))
# figrefs
bandgaps$figref <-
   c("\\labelcref{fig:MB-N02A-large-nostir-mbabs}, \\labelcref{fig:MB-N02A-large-nostir-edge}",
     "\\labelcref{fig:MB-N02A-small-nostir-mbabs}, \\labelcref{fig:MB-N02A-small-nostir-edge}",
     "\\labelcref{fig:MB-N04E-large-nostir-photodegradation}",
     "\\labelcref{fig:MB-N04H-medium-nostir-mbabs}, \\labelcref{fig:MB-N04H-medium-nostir-edge}",
     "\\labelcref{fig:MB-N04H-small-nostir-photodegradation}")
## add time (i.e., duration from t=0 until last recorded bandgap),
bandgaps$time.last.Eg <- cutoffs$bandgap
@



<<'0512P-solar-bandgaps', eval=FALSE>>=
# smallest and largest observed band gap, along with corresponding photon flux (from AM1.5G)
np.bg <-
   data.frame(bandgap.nm =
                 c(energy2wavelength(max(condensed.all$fit.Eg, na.rm = T)),
                   energy2wavelength(3.30)),
              bandgap =
                 c(max(condensed.all$fit.Eg, na.rm = T),
                   3.30),
              flux.exp =
                 c(sun %>%
                      filter(spectrum == "Class A AM1.5 simulator") %>%
                      # limit wavelength/energy range to where both exp and theory exist (from approx 1 eV to 4.5 eV)
                      filter(energy > min(sun.exp$energy) & energy < max(sun.theory$energy)) %>%
                      filter(energy > max(condensed.all$fit.Eg, na.rm = T)) %>% tail(1) %>%
                      select(cumflux) %>% unlist(use.names = F),
                   sun %>%
                      filter(spectrum == "Class A AM1.5 simulator") %>%
                      # limit wavelength/energy range to where both exp and theory exist (from approx 1 eV to 4.5 eV)
                      filter(energy > min(sun.exp$energy) & energy < max(sun.theory$energy)) %>%
                      filter(energy >= 3.30) %>% tail(1) %>%
                      select(cumflux) %>% unlist(use.names = F)),
              flux.theory =
                 c(sun %>%
                      filter(spectrum == "ASTMG173 1.5G") %>%
                      # limit wavelength/energy range to where both exp and theory exist (from approx 1 eV to 4.5 eV)
                      filter(energy > min(sun.exp$energy) & energy < max(sun.theory$energy)) %>%
                      filter(energy > max(condensed.all$fit.Eg, na.rm = T)) %>% tail(1) %>%
                      select(cumflux) %>% unlist(use.names = F),
                   sun %>%
                      filter(spectrum == "ASTMG173 1.5G") %>%
                      # limit wavelength/energy range to where both exp and theory exist (from approx 1 eV to 4.5 eV)
                      filter(energy > min(sun.exp$energy) & energy < max(sun.theory$energy)) %>%
                      filter(energy >= 3.30) %>% tail(1) %>%
                      select(cumflux) %>% unlist(use.names = F)))
# shaded areas under AM1.5G plot (used in figref-solarlamp below)
sun.theory.smallestnp.abs <-
   sun.theory %>%
   filter(energy > max(np.bg$bandgap))
sun.theory.largestnp.abs <-
   sun.theory %>%
   filter(energy > min(np.bg$bandgap))
# shaded areas under experimental solar plot (used in figref-solarlamp below)
sun.exp.smallestnp.abs <-
   sun.exp %>%
   filter(energy > max(np.bg$bandgap))
sun.exp.largestnp.abs <-
   sun.exp %>%
   filter(energy > min(np.bg$bandgap))
@



<<'0512P-tabref-growthrate', eval=FALSE, echo=FALSE>>=
this.tab <-
   growthrate %>%
   mutate(diameter = as.numeric(sub("nm", "", init.np.diam))) %>%
   arrange(diameter) %>%
   # replace diameter with diameter +- error taken from condensed.all (just because it is easier to get)
   mutate(diameterwerror = condensed.all %>% group_by(init.np.diam) %>% slice(1L) %>% pull(fit.np.diam)) %>%
   select(diameterwerror, slopewerror, interceptwerror, rsquared)
# we will have to explicitly expose the errors so siunitx can work with them in xtab
# actually, that would involve manually setting the formatting for each element anyway, so let's just print
# this.tab, collect its properly formatted output (thanks to "errors") and manually create a new tibble
xtab.growthrate <-
   tribble(
    ~diameterwerror, ~slopewerror, ~interceptwerror, ~rsquared,
    # ---          | ---         | ---             | ---      |
    "3.18(9)",       "0.059(4)",   "3.25(2)",       "0.961",
    "3.23(9)",       "0.066(4)",   "3.32(2)",       "0.963",
    "5.8(3)",        "0.022(1)",   "5.865(7)",      "0.968",
    "6.7(5)",        "0.029(2)",   "6.72(1)",       "0.941",
    "7.4(6)",        "0.041(3)",   "7.40(2)",       "0.950") %>%
   xtable()
caption(xtab.growthrate) <- paste(
   "Parameters of the linear fits in \\cref{fig:NPBE-diameter-all}. Initial diameter of",
   "the \\ch{ZnO} nanoparticles ($d_\\mathrm{i}$), growth rate during the first",
   "\\qty{10}{\\minute} ($\\Delta d$), $y$-axis intercept of the linear fit ($m$), and",
   "$R^2$ of the linear fit. Interestingly, the growth rate shows a non-linear dependence",
   "on nanoparticle size (\\textit{cf.} \\cref{fig:growthrate-vs-initial-diameter}).")
label(xtab.growthrate) <- "tab:growthrate"
names(xtab.growthrate) <-
   c("{$d_\\text{i}/\\unit{\\nm}$}",
     "{$\\Delta d/\\unit{\\nm\\per\\minute}$}",
     "{$m/\\unit{\\nm}$}",
     "{$R^2$}")
digits(xtab.growthrate) <-
   c(0, #row.names
     2, #diameter
     3, #slope
     3, #intercept
     3) #rsquared
display(xtab.growthrate) <-
   c("s", #row.names
     "f", #diameter
     "f", #slope
     "f", #intercept
     "f") #rsquared
align(xtab.growthrate) <-
   c("l", #row.names
     "S[uncertainty-mode=compact, table-format=1.2(1)]", #diameter
     "S[uncertainty-mode=compact, table-format=1.3(1)]", #slope
     "S[uncertainty-mode=compact, table-format=1.3(1)]", #intercept
     "S[table-format=1.3]") #rsquared
print(xtab.growthrate,
      floating = TRUE,
      floating.environment = "table",
      table.placement = "tbp",
      caption.placement = "top",
      hline.after = NULL,
      add.to.row = list(pos = list(-1,
                                   0,
                                   nrow(xtab.growthrate)),
                        command = c("\\toprule\n",
                                    "\\midrule\n",
                                    "\\bottomrule\n")),
      include.rownames = FALSE,
      include.colnames = TRUE,
      type = "latex",
      tabular.environment = "tabular",
      latex.environments = c("center", "small"),
      sanitize.text.function = function(x){x},
      math.style.negative = FALSE)
@


<<'0512P-tabref-bandgaps', eval=FALSE, echo=FALSE>>=
xtab.bandgaps <-
   tribble(
      ~figref, ~init.Eg, ~last.Eg, ~time.last.Eg, ~points, ~init.diam, ~last.diam, ~init.cumflux, ~last.cumflux,
      "\\labelcref{fig:MB-N04H-small-nostir-photodegradation}", "3.78(1)", "3.47(1)", "18", "23 +- 7", "3.18(9)", "5.8(3)", "6.12e+18", "3.03e+19",
      "\\labelcref{fig:MB-N02A-small-nostir-mbabs}, \\labelcref{fig:MB-N02A-small-nostir-edge}", "3.77(1)", "3.45(1)", "140", "24 +- 8", "3.23(9)", "6.2(4)", "6.81e+18", "3.19e+19",
      "\\labelcref{fig:MB-N04H-medium-nostir-mbabs}, \\labelcref{fig:MB-N04H-medium-nostir-edge}", "3.47(1)", "3.3(0)", "29", "9 +- 1", "5.8(3)", "", "3.07e+19", "5.12e+19",
      "\\labelcref{fig:MB-N02A-large-nostir-mbabs}, \\labelcref{fig:MB-N02A-large-nostir-edge}", "3.43(1)", "3.39(1)", "150", "10 +- 2", "6.7(5)", "8.6(9)", "3.40e+19", "3.92e+19",
      "\\labelcref{fig:MB-N04E-large-nostir-photodegradation}", "3.41(1)", "3.38(1)", "40", "9 +- 3", "7.4(6)", "9(1)", "3.62e+19", "4.06e+19") %>%
   xtable()
caption(xtab.bandgaps) <- paste(
   "Parameters of the Tauc analysis of the ZnO band edge of the different experiments.",
   "Showing calculated band gap, nanoparticle diameter, and corresponding photon flux of",
   "AM1.5G spectrum at first ($t=0$) and last calculated band gap value. The NP diameter at",
   "the last time clearly shows the limits of our formula for calculating ZnO diameter from band gap.")
label(xtab.bandgaps) <- "tab:bandgaps"
names(xtab.bandgaps) <-
   c("{\\textit{Cf}.\\ fig.}",
     "{At $t=0$}",
     "{Last rec.}",
     "{at last rec.}",
     "{in lin.\\ fit}",
     "{At $t=0$}",
     "{Last rec.}",
     "{At $t=0$}",
     "{Last rec.}")
digits(xtab.bandgaps) <-
   c(0, #row.names
     0, #figref
     2, #init.Eg
     2, #last.Eg
     1, #time.last.Eg
     2, #points
     2, #init.diam
     3, #last.diam
     2, #init.cumflux
     2) #last.cumflux
display(xtab.bandgaps) <-
   c("s", #row.names
     "s", #figref
     "f", #init.Eg
     "f", #last.Eg
     "d", #time.last.Eg
     "f", #points
     "f", #init.diam
     "f", #last.diam
     "e", #init.cumflux
     "e") #last.cumflux
align(xtab.bandgaps) <-
   c("l", #row.names
     "c", #figref
     "S[table-format=1.2(1)]", #init.Eg
     "S[table-format=1.2(1)]", #last.Eg
     "S[table-format=1.0]", #time.last.Eg
     # https://tex.stackexchange.com/a/200218/10824
     "S", #points
     "S[table-format=1.2(1)]", #init.diam
     "S[table-format=1.1(1)]", #last.diam
     "S[table-format=1.2e2]", #init.cumflux
     "S[table-format=1.2e2]") #last.cumflux
print(xtab.bandgaps,
      floating = TRUE,
      floating.environment = "table*",
      table.placement = "tbp",
      caption.placement = "top",
      hline.after = NULL,
      add.to.row =
         list(pos = list(-1,
                         0,
                         nrow(xtab.bandgaps)),
              command = c(paste("\\toprule\n",
                                # top header goes here
                                " & \\multicolumn{2}{c}{$E_\\text{g}/\\unit{\\eV}$} & {$t/\\unit{\\minute}$} & {Points} &",
                                "\\multicolumn{2}{c}{NP diameter/\\unit{\\nm}} &",
                                "\\multicolumn{2}{c}{Photon flux/\\unit{\\per\\second\\per\\square\\metre}} \\\\\n",
                                "\\cmidrule(lr){2-3}\\cmidrule(lr){6-7}\\cmidrule(lr){8-9}"),
                          "\\midrule\n",
                          "\\bottomrule\n")),
      include.rownames = FALSE,
      include.colnames = TRUE,
      type = "latex",
      tabular.environment = "tabular",
      latex.environments = c("center", "small"),
      sanitize.text.function = function(x){x},
      math.style.negative = FALSE)
@



<<'0512P-figref-solarlamp', eval=FALSE, echo=FALSE>>=
p <-
   ggplot() +
   ## PMMA spectrum as grey area
   geom_area(data = cuvettes %>%
                filter(energy < 5.4 & energy > 3) %>%
                filter(sampleid == "\\ch{H2O}") %>%
                mutate(scaled.intensity = 0.70 * intensity),
             aes(x = energy,
                 y = scaled.intensity),
             colour = "grey50",
             fill = "grey50") +
   # PMMA cuvette label
   annotate("text", x = 5, y = 0.65, size = 2.2,
            angle = 75, colour = "white",
            label = "PMMA cuvette") +
   ## shaded area for largest NP size
   geom_area(data = sun.theory.largestnp.abs,
             aes(x = energy, # wavelength,
                 y = intensity),
             fill = alpha("blue", 0.4),
             # fill = alpha("blue", 0.6),
             colour = NA) +
   geom_area(data = sun.exp.largestnp.abs,
             aes(x = energy, # wavelength,
                 y = intensity),
             fill = alpha("blue", 0.6),
             colour = NA) +
   # Eg LABEL and ARROW
   annotate("text",
            x = min(np.bg$bandgap), y = 1.28, # y = 1.08,
            size = 2.0,
            colour = alpha("blue", 0.6),
            label = paste0("\\qty{", formatC(min(np.bg$bandgap), format = "f", digits=2), "}{\\eV}")) +
   geom_segment(aes(x = min(np.bg$bandgap), xend = min(np.bg$bandgap),
                    y = 1.22, yend = 0.85),
                colour = alpha("blue", 0.6),
                arrow = arrow(length = unit(0.020, "npc"))) +
   ## shaded area for smallest NP size
   geom_area(data = sun.theory.smallestnp.abs,
             aes(x = energy, # wavelength,
                 y = intensity),
             fill = alpha("yellow", 0.4),
             colour = NA) +
   geom_area(data = sun.exp.smallestnp.abs,
             aes(x = energy, # wavelength,
                 y = intensity),
             fill = alpha("yellow", 0.6),
             colour = NA) +
   # Eg LABEL and ARROW
   annotate("text",
            x = max(np.bg$bandgap), y = 0.94, # y = 0.72,
            size = 2.0,
            colour = "#c2c266",
            label = paste0("\\qty{", formatC(max(np.bg$bandgap), format = "f", digits=2), "}{\\eV}")) +
   geom_segment(aes(x = max(np.bg$bandgap), xend = max(np.bg$bandgap),
                    y = 0.86, yend = 0.52),
                colour = "#c2c266", # alpha("yellow", 0.6),
                arrow = arrow(length = unit(0.020, "npc"))) +
   ## ASTM AM1.5G spectrum
   geom_line(data = sun.theory %>%
                filter(wavelength < 1000),
             aes(x = energy, # wavelength,
                 y = intensity)) +
   ## Experimental solar spectrum
   geom_line(data = sun.exp %>%
                filter(energy > 3),
             aes(x = energy, # wavelength,
                 y = intensity)) +
   coord_cartesian(xlim = c(1.42, 5.20),
                   ylim = c(0, 1.68)) +
   scale_y_continuous(expand = c(0, 0)) +
   scale_x_continuous(sec.axis =
                         sec_axis(~ 1239.842 / .,
                                  breaks = c(200, 250, 300, 400, 500, 700, 900),
                                  name = "$\\lambda/\\unit{\\nm}$")) +
   labs(x = "$E$/\\unit{\\eV}",
        # AM1.5G is shown as spectral radiance, but PMMA spectrum is OD (absorbance).
        # So we will simply put au here (also PMMA spectrum has been squeezed along y).
        y = "$I/\\text{au}$") +
   theme(legend.position = "none")
q <-
   ggplot(sun.theory %>%
               filter(energy >= min(bandgaps$last.Eg))) + #%>%
   geom_line(aes(x = energy,
                 y = cumflux),
             colour = "white") +
   # use the same x-range as the main plot
   coord_cartesian(xlim = c(1.42, 5.20)) +
   scale_x_continuous(breaks = seq(0,6,1)) +
   theme(axis.title = element_blank(),
         # invisible, but still takes up space
         axis.text = element_text(colour = NA),
         axis.ticks = element_line(colour = NA),
         panel.grid = element_blank(),
         panel.border = element_rect(colour = NA),
         # transparent plot background
         plot.background = element_blank(),
         panel.background = element_blank())
vp.p <- viewport(width = 1.000, height = 1.0, x = 0.0, y = 0.00, just = c(0, 0))
vp.q <- viewport(width = 0.994, height = 0.3, x = 1.0, y = 0.087, just = c(1, 0))
print(p, vp = vp.p)
@



<<'0512P-figref-MB-N02A-small-nostir-mbabs', eval=FALSE, echo=FALSE>>=
nth.spectra <- 1
this.data <-
   pc.abs.small.N02A.nostir %>%
   filter(time.abs %in% seq(0, length(unique(pc.abs.small.N02A.nostir$time.abs)), by = nth.spectra))
this.condensed <- condensed.abs.small.N02A.nostir
this.ceiling <- ceiling.pc.abs.small.N02A.nostir
this.fityk <-
   fityk.peaks.small.N02A.nostir.MB.max %>%
   filter(spectra < 150)
ggplot() +
   geom_errorbar(data = this.fityk %>%
                    filter(this.fityk$peakno %% 2 == 1),
                 colour = "#0B096C",
                 size = 0.2,
                 aes(x = spectra,
                     ymin = errors_min(height),
                     ymax = errors_max(height),
                     group = 1)) +
   # first point, highlighted
   geom_point(data = this.fityk %>%
                 filter(this.fityk$peakno %% 2 == 1) %>%
                 filter(spectra == 0),
              size = 1.1, # 1.75,
              colour = alpha("red", 0.30),
              aes(spectra,
                  height)) +
   geom_line(data = this.fityk %>%
                filter(this.fityk$peakno %% 2 == 1),
             colour = "#0B096C",
             size = 0.2,
             aes(spectra,
                 height,
                 group = 1)) +
   coord_cartesian(ylim = c(0, 0.6)) +
   labs(x = "$t/\\unit{\\minute}$",
        y = "$A$") +
   theme(legend.position = "none",
         #                    t    r    b    l
         plot.margin = unit(c(5.5, 32, 5.5, 5.5), "points"))
@


<<'0512P-figref-MB-N02A-small-nostir-edge', eval=FALSE, echo=FALSE>>=
nth.spectra <- 1
this.data <-
   pc.abs.small.N02A.nostir %>%
   filter(time.abs %in% seq(0, length(unique(pc.abs.small.N02A.nostir$time.abs)), by = nth.spectra))
this.condensed <-
   condensed.abs.small.N02A.nostir %>%
   filter(spectra < 150)
this.ceiling <- ceiling.pc.abs.small.N02A.nostir
this.fityk <- fityk.peaks.small.N02A.nostir.MB.max
p.edge <- ggplot() +
   geom_errorbar(data = this.condensed,
                 size = 0.2,
                 colour = alpha("#4387BF", 0.3),
                 aes(x = spectra,
                     ymin = errors_min(fit.Eg),
                     ymax = errors_max(fit.Eg))) +
   # highlight first point
   geom_point(data = this.condensed %>%
                 filter(spectra == 0),
              size = 1.25,
              colour = alpha("red", 0.30),
              aes(x = spectra,
                  y = fit.Eg)) +
   geom_point(data = this.condensed,
              shape = 21,
              size = 0.15,
              fill = "#D5B450",
              colour = "#4387BF",
              aes(x = spectra,
                  y = fit.Eg)) +
   # arrow pointing to scale
   geom_segment(aes(x = 0+25, xend = 0,
                    y = 3.55, yend = 3.55),
                colour = "#4387BF",
                size = 1,
                arrow = arrow(length = unit(0.040, "npc"))) +
   labs(x = "$t$/\\unit{\\minute}",
        y = "$E_\\text{g}$/\\unit{\\eV}") +
   theme(legend.position = "none",
         #                    t    r    b    l
         plot.margin = unit(c(5.5, 32, 5.5, 5.5), "points"))
p.edge.diam <- ggplot() +
   geom_errorbar(data = this.condensed %>%
                    filter(spectra <= subset(cutoffs, sample == "N02A-small-nostir")$diameter),
                 size = 0.2,
                 colour = alpha("#D5B450", 0.3),
                 aes(x = spectra,
                     ymin = errors_min(fit.np.diam),
                     ymax = errors_max(fit.np.diam))) +
   geom_point(data = this.condensed %>%
                 filter(spectra <= subset(cutoffs, sample == "N02A-small-nostir")$diameter),
              size = 0.1,
              colour = "#D5B450",
              aes(x = spectra,
                  y = fit.np.diam)) +
   # arrow pointing to scale
   geom_segment(aes(x = 100, xend = 100+25,
                    y = 5, yend = 5),
                colour = "#D5B450",
                size = 1,
                arrow = arrow(length = unit(0.040, "npc"))) +
   labs(x = "$t/\\unit{\\minute}$",
        y = "$d/\\unit{\\nm}$") +
   scale_y_continuous(position = "right") +
   coord_cartesian(xlim = c(0, max(this.condensed$spectra))) +
   theme(legend.position = "none",
         panel.grid = element_blank(),
         axis.title.x = element_blank(),
         axis.text.x = element_blank(),
         #                    t    r    b    l
         plot.margin = unit(c(5.5, 32, 5.5, 5.5), "points"),
         # make plot background transparent
         panel.background = element_rect(fill = NA, colour = NA),
         # make area outside panel transparent
         plot.background =
            element_rect(fill = NA,
                         colour = NA))
vp.edge <-
   viewport(width = 1, height = 1, x = 0, y = 1, just = c("left", "top"))
vp.edge.diam <-
   viewport(width  = 0.960, # width  = 0.935
            height = 0.794, # height = 0.803
            x = 0.164, y = 1, just = c("left", "top"))
print(p.edge, vp = vp.edge)
print(p.edge.diam, vp = vp.edge.diam)
@


<<'0512P-figref-MB-N04H-medium-nostir-mbabs', eval=FALSE, echo=FALSE>>=
nth.spectra <- 1
this.data <-
   pc.abs.medium.N04H.nostir %>%
   filter(time.abs %in% seq(0, length(unique(pc.abs.medium.N04H.nostir$time.abs)), by = nth.spectra))
this.condensed <- condensed.abs.medium.N04H.nostir
this.ceiling <- ceiling.pc.abs.medium.N04H.nostir
this.fityk <-
   fityk.peaks.medium.N04H.nostir.MB.max %>%
   filter(spectra < 150)
### Apply a correction: five bandgap values below 3.42 eV are clear fit outliers...
criterion <- which(condensed.abs.medium.N04H.nostir$fit.Eg < 3.42)
this.condensed$fit.Eg[criterion] <- as.numeric(NA)
# and replace the same positions of fit.np.diam with NAs...
this.condensed$fit.np.diam[criterion] <- as.numeric(NA)
# and finally, drop the linear fits for the corresponding spectra.
this.ceiling <- this.ceiling[-which(this.ceiling$spectra %in% criterion), ]
ggplot() +
   geom_errorbar(data = this.fityk %>%
                 filter(this.fityk$peakno %% 2 == 1),
              colour = alpha("#0B096C", 0.6),
              size = 0.2,
              aes(x = spectra,
                  ymin = errors_min(height),
                  ymax = errors_max(height),
                  group = 1)) +
   geom_line(data = this.fityk %>%
                 filter(this.fityk$peakno %% 2 == 1),
              colour = "#0B096C",
              size = 0.2,
              aes(spectra,
                  height,
                  group = 1)) +
   # first point, highlighted
   geom_point(data = this.fityk %>%
                 filter(this.fityk$peakno %% 2 == 1) %>%
                 filter(spectra == 0),
              size = 1.75,
              colour = alpha("red", 0.30),
              aes(spectra,
                  height)) +
   scale_x_continuous() +
   labs(x = "$t/\\unit{\\minute}$",
        y = "$A$") +
   coord_cartesian(ylim = c(0, 0.6)) +
   theme(legend.position = "none",
         #                    t    r    b    l
         plot.margin = unit(c(5.5, 32, 5.5, 5.5), "points"))
@


<<'0512P-figref-MB-N04H-medium-nostir-edge', eval=FALSE, echo=FALSE>>=
nth.spectra <- 1
this.data <-
   pc.abs.medium.N04H.nostir %>%
   filter(time.abs %in% seq(0, length(unique(pc.abs.medium.N04H.nostir$time.abs)), by = nth.spectra))
this.condensed <- condensed.abs.medium.N04H.nostir
this.ceiling <- ceiling.pc.abs.medium.N04H.nostir
this.fityk <- fityk.peaks.medium.N04H.nostir.MB.max
### Apply a correction: five bandgap values below 3.42 eV are clear fit outliers...
criterion <- which(condensed.abs.medium.N04H.nostir$fit.Eg < 3.42)
this.condensed$fit.Eg[criterion] <- as.numeric(NA)
# and replace the same positions of fit.np.diam with NAs...
this.condensed$fit.np.diam[criterion] <- as.numeric(NA)
# and finally, drop the linear fits for the corresponding spectra.
this.ceiling <- this.ceiling[-which(this.ceiling$spectra %in% criterion), ]
# limit plots for conformance with the rest of the plots
this.condensed <-
   this.condensed %>%
   filter(spectra < 50)
p.edge <- ggplot() +
   geom_errorbar(data = this.condensed,
              size = 0.2,
              colour = alpha("#4387BF", 0.3),
              aes(x = spectra,
                  ymin = errors_min(fit.Eg),
                  ymax = errors_max(fit.Eg))) +
   # highlight first point
   geom_point(data = this.condensed %>%
                 filter(spectra == 0),
              size = 1.25,
              colour = alpha("red", 0.30),
              aes(x = spectra,
                  y = fit.Eg)) +
   geom_point(data = this.condensed,
              shape = 21,
              size = 0.65,
              fill = "#D5B450",
              colour = "#4387BF",
              aes(x = spectra,
                  y = fit.Eg)) +
   # arrow pointing to scale
   geom_segment(aes(x = 1+11, xend = 1,
                    y = 3.45, yend = 3.45),
                colour = "#4387BF",
                size = 1,
                arrow = arrow(length = unit(0.040, "npc"))) +
   labs(x = "$t$/\\unit{\\minute}",
        y = "$E_\\text{g}$/\\unit{\\eV}") +
   coord_cartesian(ylim = c(3.425, 3.465),
                   xlim = c(0, max(this.condensed$spectra))) +
   scale_x_continuous() +
   theme(legend.position = "none",
         #                    t    r    b    l
         plot.margin = unit(c(5.5, 32, 5.5, 5.5), "points"))
p.edge.diam <- ggplot() +
   geom_errorbar(data = this.condensed %>%
                    filter(spectra <= subset(cutoffs, sample == "N04H-medium-nostir")$diameter),
                 size = 0.2,
                 colour = alpha("#D5B450", 0.3),
                 aes(x = spectra,
                     ymin = errors_min(fit.np.diam),
                     ymax = errors_max(fit.np.diam))) +
   geom_point(data = this.condensed %>%
                 filter(spectra <= subset(cutoffs, sample == "N04H-medium-nostir")$diameter),
              size = 0.35,
              colour = "#D5B450",
              aes(x = spectra,
                  y = fit.np.diam)) +
   # arrow pointing to scale
   geom_segment(aes(x = 35, xend = 35+11,
                    y = 6.61, yend = 6.61),
                colour = "#D5B450",
                size = 1,
                arrow = arrow(length = unit(0.040, "npc"))) +
   labs(x = "$t/\\unit{\\minute}$",
        y = "$d/\\unit{\\nm}$") +
   scale_y_continuous(position = "right") +
   coord_cartesian(ylim = c(5.9, 6.9),
                   xlim = c(0, max(this.condensed$spectra))) +
   theme(legend.position = "none",
         # panel.grid.major = element_line(colour = alpha("red", 0.5)),
         # panel.grid.minor = element_line(colour = alpha("red", 0.5)),
         panel.grid = element_blank(),
         axis.title.x = element_blank(),
         axis.text.x = element_blank(),
         #                    t    r    b    l
         plot.margin = unit(c(5.5, 32, 5.5, 5.5), "points"),
         # make plot background transparent
         panel.background = element_rect(fill = NA, colour = NA),
         # make area outside panel transparent
         plot.background =
            element_rect(fill = NA,
                         colour = NA))
vp.edge <-
   viewport(width = 1, height = 1, x = 0, y = 1, just = c("left", "top"))
vp.edge.diam <-
   viewport(width  = 1.001,
            height = 0.792,
            x = 0.193, y = 1, just = c("left", "top"))
print(p.edge, vp = vp.edge)
print(p.edge.diam, vp = vp.edge.diam)
@


<<'0512P-figref-MB-N02A-large-nostir-mbabs', eval=FALSE, echo=FALSE>>=
nth.spectra <- 1
this.data <-
   pc.abs.large.N02A.nostir %>%
   filter(time.abs %in% seq(0, length(unique(pc.abs.large.N02A.nostir$time.abs)), by = nth.spectra))
this.condensed <- condensed.abs.large.N02A.nostir
this.ceiling <- ceiling.pc.abs.large.N02A.nostir
this.fityk <-
   fityk.peaks.large.N02A.nostir.MB.max %>%
   filter(spectra < 150)
ggplot() +
   geom_errorbar(data = this.fityk %>%
                    filter(this.fityk$peakno %% 2 == 1),
                 colour = alpha("#0B096C", 0.2),
                 size = 0.2,
                 aes(x = spectra,
                     ymin = errors_min(height),
                     ymax = errors_max(height),
                     group = 1)) +
   # first point, highlighted
   geom_point(data = this.fityk %>%
                 filter(this.fityk$peakno %% 2 == 1) %>%
                 filter(spectra == 0),
              size = 1.1, # 1.75,
              colour = alpha("red", 0.30),
              aes(spectra,
                  height)) +
   geom_line(data = this.fityk %>%
                filter(this.fityk$peakno %% 2 == 1),
             colour = "#0B096C",
             size = 0.2,
             aes(spectra,
                 height,
                 group = 1)) +
   labs(x = "$t/\\unit{\\minute}$",
        y = "$A$") +
   coord_cartesian(ylim = c(0, 0.6)) +
   scale_x_continuous() +
   theme(legend.position = "none",
         #                    t    r    b    l
         plot.margin = unit(c(5.5, 32, 5.5, 5.5), "points"))
@


<<'0512P-figref-MB-N02A-large-nostir-edge', eval=FALSE, echo=FALSE>>=
nth.spectra <- 1
this.data <-
   pc.abs.large.N02A.nostir %>%
   filter(time.abs %in% seq(0, length(unique(pc.abs.large.N02A.nostir$time.abs)), by = nth.spectra))
this.condensed <-
   condensed.abs.large.N02A.nostir %>%
   filter(spectra < 40)
this.ceiling <- ceiling.pc.abs.large.N02A.nostir
this.fityk <- fityk.peaks.large.N02A.nostir.MB.max
p.edge <- ggplot() +
   geom_errorbar(data = this.condensed,
              size = 0.2,
              colour = alpha("#4387BF", 0.3),
              aes(x = spectra,
                  ymin = errors_min(fit.Eg),
                  ymax = errors_max(fit.Eg))) +
   # highlight first point
   geom_point(data = this.condensed %>%
                 filter(spectra == 0),
              size = 1.25,
              colour = alpha("red", 0.30),
              aes(x = spectra,
                  y = fit.Eg)) +
   geom_point(data = this.condensed,
              shape = 21,
              size = 0.65,
              fill = "#D5B450",
              colour = "#4387BF",
              aes(x = spectra,
                  y = fit.Eg)) +
   # arrow pointing to scale
   geom_segment(aes(x = 3+10, xend = 3,
                    y = 3.415, yend = 3.415),
                colour = "#4387BF",
                size = 1,
                arrow = arrow(length = unit(0.040, "npc"))) +
   labs(x = "$t$/\\unit{\\minute}",
        y = "$E_\\text{g}$/\\unit{\\eV}") +
   coord_cartesian(ylim = c(3.385, 3.43),
                   xlim = c(0, max(this.condensed$spectra))) +
   scale_x_continuous() +
   theme(legend.position = "none",
         #                    t    r    b    l
         plot.margin = unit(c(5.5, 32, 5.5, 5.5), "points"))
p.edge.diam <- ggplot() +
   geom_errorbar(data = this.condensed %>%
                 filter(spectra <= subset(cutoffs, sample == "N02A-large-nostir")$diameter),
              size = 0.2,
              colour = alpha("#D5B450", 0.3),
              aes(x = spectra,
                  ymin = errors_min(fit.np.diam),
                  ymax = errors_max(fit.np.diam))) +
   geom_point(data = this.condensed %>%
                 filter(spectra <= subset(cutoffs, sample == "N02A-large-nostir")$diameter),
              size = 0.35,
              colour = "#D5B450",
              aes(x = spectra,
                  y = fit.np.diam)) +
   # arrow pointing to scale
   geom_segment(aes(x = 27, xend = 27+10,
                    y = 8.0, yend = 8.0),
                colour = "#D5B450",
                size = 1,
                arrow = arrow(length = unit(0.040, "npc"))) +
   labs(x = "$t/\\unit{\\minute}$",
        y = "$d/\\unit{\\nm}$") +
   scale_x_continuous() +
   scale_y_continuous(position = "right") +
   coord_cartesian(ylim = c(6.75, 8.6),
                   xlim = c(0, max(this.condensed$spectra))) +
   theme(legend.position = "none",
         # panel.grid.major = element_line(colour = alpha("red", 0.5)),
         # panel.grid.minor = element_line(colour = alpha("red", 0.5)),
         panel.grid = element_blank(),
         axis.title.x = element_blank(),
         axis.text.x = element_blank(),
         #                    t    r    b    l
         plot.margin = unit(c(5.5, 32, 5.5, 5.5), "points"),
         # make plot background transparent
         panel.background = element_rect(fill = NA, colour = NA),
         # make area outside panel transparent
         plot.background =
            element_rect(fill = NA,
                         colour = NA))
vp.edge <-
   viewport(width = 1, height = 1, x = 0, y = 1, just = c("left", "top"))
vp.edge.diam <-
   viewport(width  = 0.974,
            height = 0.792,
            x = 0.193, y = 1, just = c("left", "top"))
print(p.edge, vp = vp.edge)
print(p.edge.diam, vp = vp.edge.diam)
@


<<'0512P-kinetic-fits'>>=
# fit straight line from zero to k1 and if k2 is not NA, from k2 to end of vector
# for each of the samples
fityk.peaks.all$k1.fit <- NA
fityk.peaks.all$k1.lwr <- NA
fityk.peaks.all$k1.upr <- NA
fityk.peaks.all$k2.fit <- NA
fityk.peaks.all$k2.lwr <- NA
fityk.peaks.all$k2.upr <- NA
# construct a kinetic param table as well
kinetic.params.MB <-
   data.frame(sample = fityk.peaks.all %>%
                 select(sample) %>%
                 unique(),
              init.np.diam = fityk.peaks.all %>%
                 select(init.np.diam) %>%
                 unique() %>%
                 unlist(use.names = F) %>%
                 sub(" nm", "", .) %>%
                 as.numeric())
kinetic.params.MB$k1 <- NA
kinetic.params.MB$k2 <- NA
kinetic.params.MB$kmean <- NA
for (i in 1:length(cutoffs$sample)) {
   # row indices which we will populate after calc linear fit for this range
   k1.rows <-
      which(fityk.peaks.all$sample == cutoffs$sample[i] &
               fityk.peaks.all$seconds < 60 * cutoffs$k1[which(cutoffs$sample == cutoffs$sample[i])])
   # use old-school indexing to update the values of k1.fit and k2.fit in place
   k1.fit <-
      lm(formula = as.numeric(conc.nlog) ~ seconds,
         data = fityk.peaks.all %>%
            filter(sample == cutoffs$sample[i]) %>%
            # use values from zero up to k1
            filter(seconds < 60 * cutoffs$k1[which(cutoffs$sample == cutoffs$sample[i])]),
         # this is important since a few rows in conc.nlog are NaN, otherwise
         # number of rows won't match when we read the predict values back into $k1.fit
         na.action = "na.exclude")
   # message used for debugging
   # message(paste(i,
   #               cutoffs$sample[i],
   #               cutoffs$k1[which(cutoffs$sample == cutoffs$sample[i])],
   #               # length of k1.fit
   #               length(predict(k1.fit)),
   #               # length of vector we are trying to put it into
   #               length(k1.rows),
   #               sep = "\t"))
   # linear fits used for plotting
   fityk.peaks.all$k1.fit[k1.rows] <- predict(k1.fit, interval = "confidence")[,1]
   fityk.peaks.all$k1.lwr[k1.rows] <- predict(k1.fit, interval = "confidence")[,2]
   fityk.peaks.all$k1.upr[k1.rows] <- predict(k1.fit, interval = "confidence")[,3]
   # slope of linear fits (k_obs,1)
   kinetic.params.MB$k1[i] <- -k1.fit$coefficients["seconds"]
   # handle k2 (if not NA) inside this if-clause
   if (!is.na(cutoffs$k2[which(cutoffs$sample == cutoffs$sample[i])])) {
      # row indices which we will populate after calc linear fit for this range
      k2.rows <-
         which(fityk.peaks.all$sample == cutoffs$sample[i] &
                  fityk.peaks.all$seconds > 60 * cutoffs$k2[which(cutoffs$sample == cutoffs$sample[i])])
      k2.fit <-
         lm(formula = as.numeric(conc.nlog) ~ seconds,
            data = fityk.peaks.all %>%
               filter(sample == cutoffs$sample[i]) %>%
               # use values from k2 to end of vector
               filter(seconds > 60 * cutoffs$k2[which(cutoffs$sample == cutoffs$sample[i])]),
            # this is important since a few rows in conc.nlog are NaN, otherwise
            # number of rows won't match when we read the predict values back into $k1.fit
            na.action = "na.exclude")
      # message used for debugging
      # message(paste(i,
      #               cutoffs$sample[i],
      #               cutoffs$k2[which(cutoffs$sample == cutoffs$sample[i])],
      #               # length of k2.fit
      #               length(predict(k2.fit)),
      #               # length of vector we are trying to put it into
      #               length(k2.rows),
      #               sep = "\t"))
      # linear fits used for plotting
      fityk.peaks.all$k2.fit[k2.rows] <- predict(k2.fit, interval = "confidence")[,1]
      fityk.peaks.all$k2.lwr[k2.rows] <- predict(k2.fit, interval = "confidence")[,2]
      fityk.peaks.all$k2.upr[k2.rows] <- predict(k2.fit, interval = "confidence")[,3]
      # slope of linear fits (k_obs,2)
      kinetic.params.MB$k2[i] <- -k2.fit$coefficients["seconds"]
   }
   kinetic.params.MB$kmean[i] <-
      mean(c(kinetic.params.MB$k1[i], kinetic.params.MB$k2[i]))
}
@



<<'0512P-tabref-kinetic-parameters-MB', eval=FALSE, echo=FALSE>>=
xtab.kinetic.params.MB <-
   kinetic.params.MB %>%
   mutate(k1 = 1E4 * k1) %>%
   mutate(k2 = 1E4 * k2) %>%
   mutate(kmean = 1E4 * kmean) %>%
   arrange(init.np.diam) %>%
   select(init.np.diam, k1, k2, kmean) %>%
   xtable()
names(xtab.kinetic.params.MB) <-
   c("{$d_\\text{i}/\\unit{\\nm}$}",
     "{$t<\\qty{20}{\\min}$}",
     "{$t>\\qty{35}{\\min}$}",
     "{Averaged}")
digits(xtab.kinetic.params.MB) <-
   c(0, #row.names
     2, #diameter
     2, #k1
     2, #k2
     2) #kmean
display(xtab.kinetic.params.MB) <-
   c("s", #row.names
     "f", #diameter
     "f", #k1
     "f", #k2
     "f") #kmean
align(xtab.kinetic.params.MB) <-
   c("l", #row.names
     "S[table-format=1.2]", #diameter
     "S[table-format=1.2]", #k1
     "S[table-format=1.2]", #k2
     "S[table-format=1.2]") #kmean
print(xtab.kinetic.params.MB,
      floating = FALSE,
      hline.after = NULL,
      add.to.row = list(pos = list(-1,
                                   -1,
                                   0,
                                   nrow(xtab.kinetic.params.MB)),
                        command = c("\\toprule\n",
                                    " & \\multicolumn{3}{c}{Rate constant, $k_\\text{obs}$/\\num[retain-unity-mantissa = false]{1E-4}\\unit{\\per\\second}} \\\\ \\cmidrule(lr){2-4}\n",
                                    "\\midrule\n",
                                    "\\bottomrule\n")),
      include.rownames = FALSE,
      include.colnames = TRUE,
      type = "latex",
      tabular.environment = "tabular",
      sanitize.text.function = function(x){x},
      math.style.negative = FALSE)
@



<<'0512P-figref-MB-ratio-fityk-CC0', eval=FALSE, echo=FALSE>>=
slice.small <-
  fityk.peaks.all %>%
  filter(np.size == "small") %>%
  filter(spectra > 60) %>%
  filter(spectra == min(spectra))
slice.medium <-
   fityk.peaks.all %>%
   filter(np.size == "medium") %>%
   filter(spectra > 50) %>%
   filter(spectra == min(spectra))
slice.large <-
  fityk.peaks.all %>%
  filter(np.size == "large") %>%
  filter(spectra > 120) %>%
  filter(spectra == min(spectra))
ggplot(data = fityk.peaks.all %>%
          filter(spectra < 150)) +
   geom_ribbon(aes(x = spectra,
                   ymin = errors_min(conc.ratio),
                   ymax = errors_max(conc.ratio),
                   group = sample,
                   fill = np.size),
               alpha = 0.3) +
   geom_point(aes(x = spectra,
                  y = conc.ratio,
                  group = sample),
              size = 0.1) +
   geom_label_repel(data = slice.small,
                    aes(x = spectra,
                        y = conc.ratio,
                        label = paste0("$d_\\mathrm{i}{=}\\qty{", gsub(" nm", "", init.np.diam), "}{\\nm}$"),
                        colour = np.size),
                    size = 2.75,
                    point.padding = 0.75,
                    box.padding = 0,
                    # default label.padding is 0.25 lines
                    label.padding = 0.25) +
   geom_label_repel(data = slice.medium,
                    aes(x = spectra,
                        y = conc.ratio,
                        label = paste0("$d_\\mathrm{i}{=}\\qty{", gsub(" nm", "", init.np.diam), "}{\\nm}$"),
                        colour = np.size),
                    size = 2.75,
                    nudge_y = 0.02,
                    point.padding = 0.75,
                    box.padding = 0,
                    # default label.padding is 0.25 lines
                    label.padding = 0.25) +
   geom_label_repel(data = slice.large,
                    aes(x = spectra,
                        y = conc.ratio,
                        label = paste0("$d_\\mathrm{i}{=}\\qty{", gsub(" nm", "", init.np.diam), "}{\\nm}$"),
                        colour = np.size),
                    size = 2.75,
                    point.padding = 0.75,
                    box.padding = 0,
                    # default label.padding is 0.25 lines
                    label.padding = 0.25) +
   scale_x_continuous(breaks = seq(0, 200, 20)) +
   scale_y_continuous(breaks = seq(0, 1, 0.2)) +
   labs(y = "$C/C_0$",
        x = "$t/\\unit{\\minute}$") +
   theme(legend.position = "none")
@



<<'0512P-figref-MB-nlog-fityk-all', eval=FALSE, echo=FALSE>>=
slice <- fityk.peaks.all %>%
   filter(spectra > 125) %>%
   filter(spectra == min(spectra))
slice2 <- fityk.peaks.all %>%
   filter(sample == "N04G-small-stir") %>%
   filter(spectra > 90) %>%
   filter(spectra == min(spectra))
ggplot(data = fityk.peaks.all %>%
          filter(spectra < 150)) +
   # confidence intervals for k1
   geom_ribbon(aes(x = spectra,
                   ymin = k1.lwr,
                   ymax = k1.upr,
                   group = sample),
               alpha = 0.15) +
   # k1 obs
   geom_line(aes(x = spectra,
                 y = k1.fit,
                 group = sample,
                 colour = np.size)) +
   # confidence intervals for k2
   geom_ribbon(aes(x = spectra,
                   ymin = k2.lwr,
                   ymax = k2.upr,
                   group = sample),
               alpha = 0.10) +
   # k2 obs
   geom_line(aes(x = spectra,
                 y = k2.fit,
                 group = sample,
                 colour = np.size)) +
   # THE DATA
   geom_point(aes(x = spectra,
                  y = conc.nlog,
                  group = sample,
                  colour = np.size),
              shape = 21,
              fill = NA,
              # fill = "#D5B450",
              size = 0.65) +
   scale_x_continuous(breaks = seq(0, 200, 20)) +
   coord_cartesian(ylim = c(-3.2, 0.01)) +
   labs(y = "$\\ln(C/C_0)$",
        x = "$t/\\unit{\\minute}$") +
   theme(legend.position = "none")
@



<<'0512P-figref-NPBE-diameter-all', eval=FALSE, echo=FALSE>>=
this.data <- condensed.all
# to plot this log-log plot, shift spectra one step to the right so we can avoid zero
this.data$spectra <- this.data$spectra + 1
ggplot() +
   geom_ribbon(data = this.data %>%
                  filter(time.abs < 80),
               aes(x = spectra,
                   ymin = errors_min(fit.np.diam),
                   ymax = errors_max(fit.np.diam),
                   group = sample,
                   fill = np.size),
               alpha = 0.2) +
   geom_point(data = this.data %>%
                 filter(time.abs > 10 & time.abs < 80),
              aes(x = spectra,
                  y = fit.np.diam,
                  group = sample),
              colour = "grey60",
              size = 0.5) +
   geom_smooth(data = this.data %>%
                  filter(time.abs <= 10),
               aes(x = spectra,
                   y = fit.np.diam,
                   group = sample),
               method = "lm",
               formula = y ~ x,
               size = 0.65,
               se = F,
               fullrange = T) +
   geom_point(data = this.data %>%
                 filter(time.abs <= 10),
              aes(x = spectra,
                  y = fit.np.diam,
                  group = sample),
              size = 0.5) +
   coord_cartesian(ylim = c(3.2, 9.5)) +
   scale_x_log10(breaks = c(1, 2, 5, 10, 20, 50, 100)) +
   scale_y_log10(breaks = c(3, 4, 5, 6, 7, 9)) +
   annotation_logticks(base = 10, sides = "bl", scaled = TRUE) +
   labs(x = "$t/\\unit{\\minute}$",
        y = "$d/\\unit{\\nm}$") +
   theme(legend.position = "none",
         axis.text = element_text(size = rel(0.8)),
         axis.title = element_text(size = rel(0.85)))
@



<<'0512P-figref-growthrate-vs-initial-diameter', eval=FALSE, echo=FALSE>>=
this.fit <- lm(formula = slope ~ intercept + I(intercept^2), data = growthrate)
ggplot(
   data = growthrate %>% arrange(desc(intercept)),
   aes(y = slope, x = intercept)) +
   geom_smooth(method = "lm", formula = y ~ x + I(x^2), se = FALSE) +
   # slope and intercept from log-linear model
   geom_errorbar(
      aes(
         x = interceptwerror,
         ymin = errors_min(slopewerror),
         ymax = errors_max(slopewerror))) +
   geom_point(size = 0.9) +
   scale_y_continuous(breaks = seq(0, 0.08, 0.02)) +
   annotate(geom = "text",
      x = 5.5, y = 0.048, colour = "blue", size = 2.5,
      label = paste0(
         "$", "\\Delta d = ",
         "\\num[uncertainty-mode=compact]{", formatC(summary(this.fit)$coef[2,1], format="f", digits=2),
         "+-",
         formatC(summary(this.fit)$coef[2,2], format="f", digits=2), "}",
         "d_\\text{i}",
         " + ",
         "\\num[uncertainty-mode=compact]{", formatC(summary(this.fit)$coef[3,1], format="f", digits=3),
         "+-",
         formatC(summary(this.fit)$coef[3,2], format="f", digits=3), "}",
         "d_\\text{i}^2",
         " + ",
         "\\num[uncertainty-mode=compact]{", formatC(summary(this.fit)$coef[1,1], format="f", digits=2),
         "+-",
         formatC(summary(this.fit)$coef[1,2], format="f", digits=2), "}",
         "$")) +
   annotate(geom = "text",
      x = 5.5 - 0.5, y = 0.048, colour = "blue", size = 2.5,
      label = paste0(
         "$R^2 = \\num{",
         formatC(summary(this.fit)$adj.r.squared, format="fg", digits=2),
         "}", "$")) +
   coord_flip() +
   labs(y = "$\\Delta d/\\unit{\\nm\\per\\minute}$",
        x = "$d_\\text{i}/\\unit{\\nm}$") +
   theme(
      legend.position = "none",
      axis.text = element_text(size = rel(0.8)),
      axis.title = element_text(size = rel(0.85)))
@



<<'0512P-figref-tocgraphic', eval=FALSE, echo=FALSE>>=
p <-
   ggplot() +
   ## shaded area for largest NP size
   geom_area(data = sun.theory.largestnp.abs %>% filter(energy <= max(np.bg$bandgap)),
             aes(x = energy, # wavelength,
                 y = intensity),
             fill = alpha("#e5e619", 0.5),
             colour = NA) +
   ## shaded area for smallest NP size
   geom_area(data = sun.theory.smallestnp.abs,
             aes(x = energy, # wavelength,
                 y = intensity),
             fill = alpha("#e5e619", 0.3),
             colour = NA) +
   ### Eg LABELs and ARROW
   # arrow from 3.80 eV to 3.30 eV labels
   geom_segment(aes(x = max(np.bg$bandgap) - 0.08, xend = min(np.bg$bandgap) + 0.05 + 0.08,
                    y = 0.72 + 0.08, yend = 1.08 - 0.08),
                colour = "#c6c350", # alpha("blue", 0.5),
                size = 1.4,
                arrow = arrow(length = unit(0.020, "npc"))) +
   # smallest band gap
   annotate("text",
            x = min(np.bg$bandgap) + 0.05, y = 1.08, # y = 1.08,
            size = 3.0,
            colour = "#b6b15f", # alpha("blue", 0.6),
            label = paste0("\\qty{", formatC(min(np.bg$bandgap), format = "f", digits=2), "}{\\eV}")) +
   # largest band gap
   annotate("text",
            x = max(np.bg$bandgap), y = 0.72, # y = 0.72,
            size = 3.0,
            colour = "#c6c350", # "#c2c266",
            label = paste0("\\qty{", formatC(max(np.bg$bandgap), format = "f", digits=2), "}{\\eV}")) +
   # diameter Eg relationship
   annotate("text",
            size = 3,
            colour = "gray40",
            hjust = 1, vjust = 1,
            x = 4.3, y = 1.5,
            label = "$d \\propto \\displaystyle\\frac{1}{\\sqrt{E_\\text{g}}}$") +
   ## ASTM AM1.5G spectrum
   geom_line(data = sun.theory,
             size = 0.25,
             aes(x = energy, # wavelength,
                 y = intensity)) +
   scale_y_continuous(expand = c(0, 0)) +
   scale_x_continuous(expand = c(0, 0)) +
   coord_cartesian(xlim = c(1.23, 4.3)) +
   theme_cowplot(12) +
   theme(legend.position = "none",
         axis.title = element_blank(),
         axis.text = element_blank(),
         axis.ticks = element_blank())
particle_file <- "images/GYV4mn-particle.png"
ggdraw() +
   draw_image(particle_file, scale = 0.5, x = 0.34, y = 0.3,
              hjust = 0.5, vjust = 0.5) +
   draw_plot(p)
@
